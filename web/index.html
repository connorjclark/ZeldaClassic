<!DOCTYPE html>
<html>

<head>
  <title>Zelda Classic</title>
  <style>
    body {
      margin: 0;
      background-color: black;
      color: whitesmoke;
      font-size: 18px;
      font-family: monospace;
    }

    .hidden {
      display: none !important;
    }

    a {
      color: whitesmoke;
    }

    header {
      padding: 5px;
    }

    button {
      font-size: 18px;
      background: none;
      color: white;
      border: none;
      cursor: pointer;
    }

    button.active {
      color: gold;
    }

    button:active {
      transform: translate(1px, 1px);
    }

    .about {
      margin: 0 5vw;
    }

    .quest-list {
      height: 100vh;
      overflow-y: scroll;
      display: flex;
    }

    .quest-list__entries {
      flex-shrink: 0;
      overflow-y: scroll;
    }

    .quest-list__entry {
      margin: 5px;
      font-size: 16px;
      user-select: none;
      cursor: pointer;
    }

    .quest-list__entry:hover {
      background-color: #2a3333;
    }

    .quest-list__entry.selected {
      padding-left: 5px;
      color: gold;
    }

    .quest-list__current button {
      font-size: 30px;
    }

    .emscripten {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .content {
      display: flex;
      justify-content: center;
    }

    canvas {
      border: 0 none;
    }
  </style>
</head>

<body>
  <header>
    <button class="panel-button" data-panel=".about">About</button>
    <button class="panel-button" data-panel=".quest-list">Quest List</button>

    <div class="hidden panel about">
      <p>
        This is an alpha version of Zelda Classic for the browser. You can expect crashes, occasional sound hiccups, and
        other bugs.
        But for the most part things should work well enough to play any quest that the Windows version can handle.
      </p>
      <p>
        Currently, this seems to work best in FireFox.
      </p>
      <p>
        Find a quest from the Quest List and hit Play to quicky load it. If a save file already exists, it will load
        instantly.
        Otherwise, it will load after you input a save file name.
      </p>
      <p>
        To report issues, contact Connor (discord connorclark#9300) or file an issue on the <a target="_blank"
          href="https://github.com/ArmageddonGames/ZeldaClassic">GitHub</a> issue tracker.
      </p>
    </div>

    <div class="hidden panel quest-list">
      <div class="quest-list__entries"></div>
      <div class="quest-list__current"></div>
    </div>
  </header>
  <div class="emscripten">
    <progress value="0" max="100" id="progress"></progress>
    <div id="status">Downloading...</div>
  </div>

  <div class="content">
    <canvas id="canvas" oncontextmenu="event.preventDefault()"></canvas>
  </div>

  <template class="tmpl-selected-quest">
    <div><span class="name"></span></div>

    <div>By: <span class="author"></span></div>
    <div>Genre: <span class="genre"></span></div>
    <div>ZC Version: <span class="version"></span></div>

    <br>

    <div>
      <button>Play!</button>
    </div>

    <br>

    <span class="description"></span>

    <div class="images"></div>
  </template>

  <script>
    window.ZC = {
      pathToUrl: {},
      createPathFromUrl(url) {
        const urlSplit = url.split('/');
        const filename = urlSplit[urlSplit.length - 1];
        const path = `/_quests/${filename}`;
        return path;
      },
    };
  </script>

  <script type="module">
    // TODO: es6 would be better, but there is an issue:
    // https://github.com/emscripten-core/emscripten/issues/16625
    // import initModule from './zelda.mjs';

    try {
      const statusElement = document.getElementById('status');
      const progressElement = document.getElementById('progress');

      const args = [];
      const params = new URLSearchParams(location.search);
      if (params.get('quest') && params.get('dmap') && params.get('screen')) {
        args.push('-test', '/_quests/' + params.get('quest'), params.get('dmap'), params.get('screen'));
        if (params.get('retsquare')) args.push(params.get('retsquare'));
      }

      // window.Module = await initModule({
      window.Module = {
        arguments: args,
        canvas: document.querySelector('canvas'),
        setStatus: function (text) {
          if (!text || text === 'Running...') return;
          if (!Module.setStatus.last) Module.setStatus.last = { time: Date.now(), text: '' };

          if (text === 'Ready') {
            progressElement.value = null;
            progressElement.max = null;
            progressElement.hidden = true;
            statusElement.hidden = true;
            return;
          }

          if (text === Module.setStatus.last.text) return;
          const m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
          const now = Date.now();
          if (m && now - Module.setStatus.last.time < 30) return; // if this is a progress update, skip it if too soon
          Module.setStatus.last.time = now;
          Module.setStatus.last.text = text;
          if (m) {
            text = m[1];
            progressElement.value = parseInt(m[2]) * 100;
            progressElement.max = parseInt(m[4]) * 100;
            progressElement.hidden = false;
          } else {
            progressElement.max = null;
            progressElement.hidden = true;
          }
          statusElement.innerHTML = text;
        },
        expectedDataFileDownloads: 0,
        totalDependencies: 0,
        monitorRunDependencies: function (left) {
          Module.totalDependencies = Math.max(Module.totalDependencies, left);
          Module.setStatus(left ? 'Preparing... (' + (Module.totalDependencies - left) + '/' + Module.totalDependencies + ')' : '');
        }
      };

      const resize = () => {
        let w = 640;
        let h = 480;
        const heightAvail = innerHeight - document.querySelector('header').clientHeight;
        const canvasScale = Math.min(innerWidth / w, heightAvail / h);
        canvas.style.width = (Math.floor(w * canvasScale)) + "px";
        canvas.style.height = (Math.floor(h * canvasScale)) + "px";
      };
      window.addEventListener('resize', resize);
      resize();

      const requestPersist = () => {
        navigator.storage.persist();
        canvas.removeEventListener('click', requestPersist);
      }
      canvas.addEventListener('click', requestPersist);

      for (const el of [...document.querySelectorAll('.panel-button')]) {
        el.addEventListener('click', () => {
          for (const buttonEl of document.querySelectorAll('.panel-button')) {
            const panelEl = document.querySelector(buttonEl.getAttribute('data-panel'));
            if (el === buttonEl) {
              buttonEl.classList.toggle('active');
              panelEl.classList.toggle('hidden');
            } else {
              buttonEl.classList.remove('active');
              panelEl.classList.add('hidden');
            }
          }
        });
      }

      await renderQuestList();
    } catch (err) {
      console.error(err);
      document.querySelector('.content').textContent = err.toString();
    }

    async function renderQuestList() {
      const questListEl = document.querySelector('.quest-list');
      const questListEntriesEl = questListEl.querySelector('.quest-list__entries');
      const questListCurrentEl = questListEl.querySelector('.quest-list__current');
      const questListCurrentTemplate = document.querySelector('.tmpl-selected-quest');

      const response = await fetch("https://hoten.cc/quest-maker/play/quest-manifest.json");
      const quests = await response.json();

      for (const quest of quests) {
        if (!quest.urls.length) continue;

        const url = quest.urls[0];
        const path = window.ZC.createPathFromUrl(url);
        const questParamValue = path.replace('/_quests/', '');

        const el = document.createElement('div');
        el.classList.add('quest-list__entry');
        el.setAttribute('data-quest-param', questParamValue);
        el.setAttribute('data-quest-index', quests.indexOf(quest));
        el.append(quest.name);
        questListEntriesEl.append(el);
      }

      questListEntriesEl.addEventListener('click', (e) => {
        const entryEl = e.target.closest('.quest-list__entry');
        if (!entryEl) return;

        const questParamValue = entryEl.getAttribute('data-quest-param');
        const questIndex = Number(entryEl.getAttribute('data-quest-index'));
        const quest = quests[questIndex];

        document.querySelector('.quest-list__entry.selected')?.classList.remove('selected');
        entryEl.classList.add('selected');

        const contentEl = questListCurrentTemplate.content.cloneNode(true);
        contentEl.querySelector('.name').textContent = quest.name;
        contentEl.querySelector('.author').textContent = quest.author;
        contentEl.querySelector('.genre').textContent = quest.genre;
        contentEl.querySelector('.version').textContent = quest.zcVersion;
        contentEl.querySelector('.description').textContent = quest.description;
        const imagesEl = contentEl.querySelector('.images');
        for (const imgUrl of quest.imageUrls) {
          const imgEl = document.createElement('img');
          imgEl.src = 'https://hoten.cc/quest-maker/play/' + imgUrl;
          imagesEl.append(imgEl);
        }
        contentEl.querySelector('button').addEventListener('click', () => {
          const playQuestUrl = new URL(location.href);
          playQuestUrl.searchParams.set('quest', questParamValue);
          console.log(playQuestUrl.toString());
          window.location.href = playQuestUrl;
        });

        questListCurrentEl.textContent = '';
        questListCurrentEl.append(contentEl);
      });

      document.querySelector('.quest-list__entry').click();
    }
  </script>
  <script async src="./zelda.js"></script>
</body>

</html>