<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no">
  <title>Zelda Classic</title>
  <style>
    body {
      margin: 0;
      background-color: black;
      color: whitesmoke;
      font-size: 18px;
      font-family: monospace;
    }

    body.canvas-focus {
      overscroll-behavior: none;
      overflow-y: hidden;
    }

    .hidden {
      display: none !important;
    }

    .flex {
      display: flex;
    }

    .justify-evenly {
      justify-content: space-evenly;
    }

    a {
      color: whitesmoke;
    }

    header {
      display: flex;
      justify-content: space-between;
      padding: 5px;
    }

    progress {
      margin-right: 5px;
    }

    button {
      font-size: 18px;
      background: none;
      color: white;
      border: none;
      cursor: pointer;
    }

    button.active {
      color: gold;
    }

    button:active {
      transform: translate(1px, 1px);
    }

    .about {
      margin: 0 5vw;
    }

    .quest-list {
      height: 100vh;
      overflow-y: scroll;
      display: flex;
    }

    .quest-list__entries {
      flex-shrink: 0;
      overflow-y: scroll;
    }

    .quest-list__entry {
      margin: 5px;
      font-size: 16px;
      user-select: none;
      cursor: pointer;
    }

    .quest-list__entry:hover {
      background-color: #2a3333;
    }

    .quest-list__entry.selected {
      padding-left: 5px;
      color: gold;
    }

    .quest-list__current button {
      font-size: 30px;
    }

    .quest-list__current img {
      max-width: 50%;
    }

    .emscripten {
      display: flex;
      align-items: center;
    }

    .content {
      display: flex;
      justify-content: center;
    }

    canvas {
      border: 0 none;
    }

    .touch-inputs {
      display: none;
      margin: 15vh 5vh;
      flex-grow: 1;
      align-items: end;
      justify-content: center;
    }

    @media only screen and (hover: none) {
      .touch-inputs {
        display: flex;
      }
    }

    .touch-input {
      color: white;
      font-weight: bold;
      padding: 15px 4px;
      width: 100%;
      height: 100%;
      user-select: none;
      pointer-events: all;
      text-align: center;
    }

    .touch-input.pressed {
      transform: translate(2px, 2px);
    }

    .dpad {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
    }

    .dpad .touch-input {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 0;
      width: 5vw;
      height: 5vw;
    }
  </style>
</head>

<body>
  <header>
    <div class="panel-buttons">
      <button class="panel-button" data-panel=".about">About</button>
      <button class="panel-button" data-panel=".quest-list">Quest List</button>
    </div>

    <div class="emscripten">
      <progress value="0" max="100" id="progress"></progress>
      <div id="status">Downloading...</div>
    </div>
  </header>

  <div>
    <div class="hidden panel about">
      <p>
        This is an alpha version of Zelda Classic for the browser. You can expect crashes, occasional sound hiccups, and
        other bugs.
        But for the most part things should work well enough to play any quest that the Windows version can handle.
      </p>
      <p>
        Currently, this seems to work best in FireFox.
      </p>
      <p>
        Find a quest from the Quest List and hit Play to quicky load it. If a save file already exists, it will load
        instantly.
        Otherwise, it will load after you input a save file name.
      </p>
      <p>
        To report issues, contact Connor (discord connorclark#9300) or file an issue on the <a target="_blank"
          href="https://github.com/ArmageddonGames/ZeldaClassic">GitHub</a> issue tracker.
      </p>
    </div>

    <div class="hidden panel quest-list">
      <div class="quest-list__entries"></div>
      <div class="quest-list__current"></div>
    </div>
  </div>

  <div class="content">
    <div class="touch-inputs">
      <div class="dpad">
        <div class="touch-input" data-x="-1" data-y="-1"></div>
        <div class="touch-input" data-x="0" data-y="-1">U</div>
        <div class="touch-input" data-x="1" data-y="-1"></div>
        <div class="touch-input" data-x="-1" data-y="0">L</div>
        <div></div>
        <div class="touch-input" data-x="1" data-y="0">R</div>
        <div class="touch-input" data-x="-1" data-y="1"></div>
        <div class="touch-input" data-x="0" data-y="1">D</div>
        <div class="touch-input" data-x="1" data-y="1"></div>
      </div>
    </div>

    <canvas id="canvas" oncontextmenu="event.preventDefault()"></canvas>

    <div class="touch-inputs">
      <div style="width: 100%">
        <div class="flex justify-evenly" style="margin: 5vh 0">
          <div class="touch-input" data-action="Start">Start</div>
          <div class="touch-input" data-action="Map">Map</div>
        </div>
        <div class="flex justify-evenly" style="margin: 5vh 0">
          <div class="touch-input" data-action="L">L</div>
          <div class="touch-input" data-action="R">R</div>
        </div>
        <div class="flex justify-evenly" style="margin: 5vh 0">
          <div class="touch-input" data-action="B">B</div>
          <div class="touch-input" data-action="A">A</div>
        </div>
      </div>
    </div>
  </div>

  <template class="tmpl-selected-quest">
    <div><span class="name"></span></div>

    <div>By: <span class="author"></span></div>
    <div>Genre: <span class="genre"></span></div>
    <div>ZC Version: <span class="version"></span></div>
    <div>
      <a class="purezc-link" target="_blank">View on PureZC</a>
    </div>

    <br>

    <div>
      <button>Play!</button>
    </div>

    <br>

    <span class="description"></span>

    <div class="images"></div>
  </template>

  <script>
    async function fetchWithProgress(url, progressCb) {
      const response = await fetch(url);
      const contentLength = Number(response.headers.get('Content-Length')) || 0;
      const contentType = response.headers.get('Content-Type');

      let data;
      if (contentLength === 0) {
        progressCb(null, null, false);
        data = new Uint8Array(await response.arrayBuffer());
        progressCb(null, null, true);
      } else {
        const reader = response.body.getReader();
        let received = 0;
        const chunks = [];
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          chunks.push(value);
          received += value.length;
          progressCb(received, contentLength, false);
        }

        data = new Uint8Array(received);
        let pos = 0;
        for (const chunk of chunks) {
          data.set(chunk, pos);
          pos += chunk.length;
        }

        progressCb(received, contentLength, true);
      }

      if (contentType === 'application/json') {
        const json = new TextDecoder('utf-8').decode(data);
        return JSON.parse(json);
      }

      return data;
    };

    window.ZC = {
      pathToUrl: {},
      createPathFromUrl(url) {
        const urlSplit = url.split('/');
        const filename = urlSplit[urlSplit.length - 1];
        const path = `/_quests/${filename}`;
        return path;
      },
      fetch(url) {
        return fetchWithProgress(url, (received, total, done) => {
          if (done) {
            Module.setStatus('Ready');
          } else if (received && total) {
            Module.setStatus(`Fetching file (${received}/${total})`);
          } else {
            Module.setStatus('Fetching file');
          }
        });
      },
    };
  </script>

  <script>
    // TODO: es6 would be better, but there is an issue:
    // https://github.com/emscripten-core/emscripten/issues/16625
    // import initModule from './zelda.mjs';

    async function main() {
      try {
        const statusElement = document.getElementById('status');
        const progressElement = document.getElementById('progress');

        const args = [];
        const params = new URLSearchParams(location.search);
        if (params.get('quest') && params.get('dmap') && params.get('screen')) {
          args.push('-test', '/_quests/' + params.get('quest'), params.get('dmap'), params.get('screen'));
          if (params.get('retsquare')) args.push(params.get('retsquare'));
        }

        // window.Module = await initModule({
        window.Module = {
          arguments: args,
          canvas: document.querySelector('canvas'),
          onRuntimeInitialized: () => {
            setupTouchControls();
          },
          setStatus: function (text) {
            if (!text || text === 'Running...') return;
            if (!Module.setStatus.last) Module.setStatus.last = { time: Date.now(), text: '' };

            if (text === 'Ready') {
              progressElement.value = null;
              progressElement.max = null;
              progressElement.hidden = true;
              statusElement.hidden = true;
              return;
            }

            statusElement.hidden = false;

            if (text === Module.setStatus.last.text) return;
            const m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
            const now = Date.now();
            if (m && now - Module.setStatus.last.time < 30) return; // if this is a progress update, skip it if too soon
            Module.setStatus.last.time = now;
            Module.setStatus.last.text = text;
            if (m) {
              text = m[1];
              progressElement.value = parseInt(m[2]) * 100;
              progressElement.max = parseInt(m[4]) * 100;
              progressElement.hidden = false;
            } else {
              progressElement.max = null;
              progressElement.hidden = true;
            }
            statusElement.innerHTML = text;
          },
          expectedDataFileDownloads: 0,
          totalDependencies: 0,
          monitorRunDependencies: function (left) {
            Module.totalDependencies = Math.max(Module.totalDependencies, left);
            Module.setStatus(left ? 'Preparing... (' + (Module.totalDependencies - left) + '/' + Module.totalDependencies + ')' : '');
          }
        };

        window.addEventListener('resize', resize);
        resize();

        const requestPersist = () => {
          navigator.storage.persist();
          canvas.removeEventListener('click', requestPersist);
        }
        canvas.addEventListener('click', requestPersist);

        for (const el of [...document.querySelectorAll('.panel-button')]) {
          el.addEventListener('click', () => {
            for (const buttonEl of document.querySelectorAll('.panel-button')) {
              const panelEl = document.querySelector(buttonEl.getAttribute('data-panel'));
              if (el === buttonEl) {
                buttonEl.classList.toggle('active');
                if (panelEl) panelEl.classList.toggle('hidden');
              } else {
                buttonEl.classList.remove('active');
                if (panelEl) panelEl.classList.add('hidden');
              }
            }

            const canvasFocus = !document.querySelector('.panel-button.active');
            document.body.classList.toggle('canvas-focus', canvasFocus);
            document.querySelector('.content').classList.toggle('hidden', !canvasFocus);
            if (canvasFocus) {
              resize();
              document.body.scrollIntoView();
            }
          });
        }
        document.body.classList.toggle('canvas-focus', true);

        await renderQuestList();
      } catch (err) {
        console.error(err);
        document.querySelector('.content').textContent = err.toString();
      }
    }

    function resize() {
      let w = 640;
      let h = 480;
      const heightAvail = innerHeight - document.querySelector('header').clientHeight;
      const canvasScale = Math.min(innerWidth / w, heightAvail / h);
      canvas.style.width = (Math.floor(w * canvasScale)) + "px";
      canvas.style.height = (Math.floor(h * canvasScale)) + "px";
    }

    async function renderQuestList() {
      const questListEl = document.querySelector('.quest-list');
      const questListEntriesEl = questListEl.querySelector('.quest-list__entries');
      const questListCurrentEl = questListEl.querySelector('.quest-list__current');
      const questListCurrentTemplate = document.querySelector('.tmpl-selected-quest');

      const response = await fetch("https://hoten.cc/quest-maker/play/quest-manifest.json");
      const quests = await response.json();

      for (const quest of quests) {
        if (!quest.urls.length) continue;

        const url = quest.urls[0];
        const path = window.ZC.createPathFromUrl(url);
        const questParamValue = path.replace('/_quests/', '');

        const el = document.createElement('div');
        el.classList.add('quest-list__entry');
        el.setAttribute('data-quest-param', questParamValue);
        el.setAttribute('data-quest-index', quests.indexOf(quest));
        el.append(quest.name);
        questListEntriesEl.append(el);
      }

      questListEntriesEl.addEventListener('click', (e) => {
        const entryEl = e.target.closest('.quest-list__entry');
        if (!entryEl) return;

        const questParamValue = entryEl.getAttribute('data-quest-param');
        const questIndex = Number(entryEl.getAttribute('data-quest-index'));
        const quest = quests[questIndex];

        document.querySelector('.quest-list__entry.selected')?.classList.remove('selected');
        entryEl.classList.add('selected');

        const contentEl = questListCurrentTemplate.content.cloneNode(true);
        contentEl.querySelector('.name').textContent = quest.name;
        contentEl.querySelector('.author').textContent = quest.author;
        contentEl.querySelector('.genre').textContent = quest.genre;
        contentEl.querySelector('.version').textContent = quest.zcVersion;
        contentEl.querySelector('.description').textContent = quest.description;
        contentEl.querySelector('.purezc-link').href = quest.projectUrl;
        const imagesEl = contentEl.querySelector('.images');
        for (const imgUrl of quest.imageUrls) {
          const imgEl = document.createElement('img');
          imgEl.src = 'https://hoten.cc/quest-maker/play/' + imgUrl;
          imagesEl.append(imgEl);
        }
        contentEl.querySelector('button').addEventListener('click', () => {
          const playQuestUrl = new URL(location.href);
          playQuestUrl.searchParams.set('quest', questParamValue);
          console.log(playQuestUrl.toString());
          window.location.href = playQuestUrl;
        });

        questListCurrentEl.textContent = '';
        questListCurrentEl.append(contentEl);
      });

      document.querySelector('.quest-list__entry').click();
    }

    function setupTouchControls() {
      const createKeyEvent = Module.cwrap('create_synthetic_key_event', null, ['int', 'int']);
      const EVENTS = {
        KEY_DOWN: 10,
        KEY_CHAR: 11,
        KEY_UP: 12,
      };
      const KEY_CODES = {
        B: 217,
        A: 219,
        Start: 67,
        Map: 75,
        L: 26,
        R: 24,
        Left: 82,
        Right: 83,
        Down: 84,
        Up: 85,
      };
      const getDirectionalKey = (x, y) => {
        if (x === -1) return KEY_CODES.Left;
        if (x === 1) return KEY_CODES.Right;
        if (y === -1) return KEY_CODES.Down;
        if (y === 1) return KEY_CODES.Up;
      }
      const sendKeyEvent = (eventType, key) => {
        if (eventType === 'touchstart') createKeyEvent(EVENTS.KEY_DOWN, key);
        if (eventType === 'touchmove' || eventType === 'touchstart') createKeyEvent(EVENTS.KEY_CHAR, key);
        if (eventType === 'touchend') createKeyEvent(EVENTS.KEY_UP, key);
      };

      const getKeysForInputElement = (el) => {
        const action = el.getAttribute('data-action');
        if (action) {
          return [KEY_CODES[action]];
        }

        const keys = [];
        const x = Number(el.getAttribute('data-x'));
        const y = Number(el.getAttribute('data-y'));
        if (x) keys.push(getDirectionalKey(x, 0));
        if (y) keys.push(getDirectionalKey(0, y));

        return keys;
      }

      for (const touchInputsEl of document.querySelectorAll('.touch-inputs')) {
        let activeInputEl = null;
        const setActiveInputEl = el => {
          if (activeInputEl) activeInputEl.classList.remove('pressed');
          activeInputEl = el;
          if (activeInputEl) activeInputEl.classList.add('pressed');
        };

        const touchFn = (eventType, e) => {
          let touch;
          if (eventType === 'touchend') {
            if (e.targetTouches.length !== 0) return;
            touch = e.changedTouches[0];
          } else {
            if (e.targetTouches.length !== 1) return;
            touch = e.targetTouches[0];
          }

          const elementMouseIsOver = document.elementFromPoint(touch.clientX, touch.clientY);
          const inputEl = elementMouseIsOver.classList.contains('touch-input') ? elementMouseIsOver : null;

          if (!inputEl && elementMouseIsOver.closest('.touch-inputs') === touchInputsEl && eventType !== 'touchend') {
            // In the "dead zone" between the inputs (ex: the middle of the dpad).
            return;
          }

          if (activeInputEl && (inputEl !== activeInputEl || !inputEl)) {
            for (const key of getKeysForInputElement(activeInputEl)) {
              sendKeyEvent('touchend', key);
            }
          }

          if (!inputEl) {
            setActiveInputEl(null);
            return;
          }

          for (const key of getKeysForInputElement(inputEl)) {
            sendKeyEvent(eventType, key);
          }

          setActiveInputEl(eventType === 'touchend' ? null : inputEl);
        };

        touchInputsEl.addEventListener('touchstart', e => touchFn('touchstart', e));
        touchInputsEl.addEventListener('touchmove', e => touchFn('touchmove', e));
        touchInputsEl.addEventListener('touchend', e => touchFn('touchend', e));
        touchInputsEl.addEventListener('touchcancel', e => touchFn('touchend', e));
        touchInputsEl.addEventListener('contextmenu', e => e.preventDefault());
      }
    }

    main();
  </script>
  <script src="zc.data.js"></script>
  {{{ SCRIPT }}}
</body>

</html>