const int MASTER_BOOMERANG_STATE_FIRED = 0;
const int MASTER_BOOMERANG_STATE_RETURNING = 1;

const int BOOMERANG_ITEM_PICKUP = 1; //Boomerang item pickup capabilities:
//0 - No item pickup, 1 - Drag items around, 2 - Instant delivery, like in 2.10.


//D0 - Damage. Set to negative to generate damaging particles. 
//     For instance, 8 - normal boomerang with damage of 8, -8 - boomerang with 
//     damage of 8 generates damaging particles while flying. Particles always
//     have damage of 2 and use Fire defense for enemy interaction.
//D1 - Main boomerang sprite
//D2 - Boomerang movement speed
//D3 - If set to 1+, Link can control it`s flight by pressing Left and right, like racing car.
//     Higher value, sharper turns allowed.
//D4 - BS Zelda-styled Mighty penetrating boomerang. Set to 1 to enable.
//D5 - Range of limited range boomerang, like wooden one. Set to 0 for infinite range.  
//D6 - Sprite for sparkle particles generated by flying boomerang. Set to 0 to disable. 
ffc script MasterBoomerang{
	void run (int dam, int sprite, int speed, int steer, int mighty, int range, int sparkle){
		CheckMaxLweapons(this, 1);
		
		int state = MASTER_BOOMERANG_STATE_FIRED;
		bool expired = false;
		bool magic = false;
		bool fire = false;
		int sparkletimer = 0;
		int soundtimer = 0;
		int cooldown = 15;
		
		if ((range==0)&&(sparkle>0)) magic = true; //All boomerangs with infinite range are counted as Magic boomerangs
		if ((dam<0)&&(sparkle>0)) fire = true;//Set D0 to negative value to turn on Fire boomerang.
		itemdata it = Game->LoadItemData(this->InitD[7]);
		int lvl = it->Level;
		int triggers[4] = {68,69,70,90};//Trigger flags.
		if (lvl<2) triggers[1] = 0;
		if (lvl<3) triggers[2] = 0; 
		int blockers[4] = {114,115,116,118};//Blocker combo types.
		if (lvl>2) blockers[1] = 0;
		if (lvl>1) blockers[0] = 0;
		
		lweapon l = LweaponInit (this, LW_GHOSTED, Abs(dam), sprite, SFX_BRANG);
		int angle = GetFiringAngle();
		LweaponSetFlag(l, LWF_NO_FALL);
		LweaponSetFlag(l, LWF_MOVE_OFFSCREEN);
		LweaponSetFlag(l, LWF_AUTO_DIR_UPDATE);
		SetLweaponHitboxOffsets(l,2,2,2,2);
		SetEnemyDefense(l, NPCD_BRANG);
		if (BOOMERANG_ITEM_PICKUP==1) LweaponSetFlag(l, LWF_CAN_PICKUP_ITEMS);
		else if (BOOMERANG_ITEM_PICKUP==2) LweaponSetFlag(l, LWF_CAN_INSTA_DELIVER_ITEMS);
		if (mighty>0) LweaponSetFlag(l, LWF_PENETRATING);
		SetAngularMovement(this, angle, speed);
		while(true){
			if (state==MASTER_BOOMERANG_STATE_FIRED){
				if (steer>0){
					angle = ArcTan(this->Vx, this->Vy)*57.2958;
					if (Link->InputLeft){
						angle -= steer;
						SetAngularMovement(this, angle, speed);
					}
					if (Link->InputRight){
						angle += steer;
						SetAngularMovement(this, angle, speed);
					}
				}
				if (OnScreenEdge(l)){
					LweaponSetFlag(l, LWF_PENETRATING);
					state = MASTER_BOOMERANG_STATE_RETURNING;
				}
				if (BlockedByEnemy(l)){
					l->CollDetection = false;
					LweaponSetFlag(l, LWF_PENETRATING);
					state = MASTER_BOOMERANG_STATE_RETURNING;
				}
				for (int i=0; i<=3; i++){
					if (HitSecretTrigger (l, triggers[i], SFX_SECRET, true)){
						if (mighty&&(lvl>3)) continue;
						LweaponSetFlag(l, LWF_PENETRATING);
						state = MASTER_BOOMERANG_STATE_RETURNING;
					}
					if (mighty&&(lvl>3)) continue;
					if (BlockedByCombo (l, blockers[i], SFX_CLINK)){
						LweaponSetFlag(l, LWF_PENETRATING);
						state = MASTER_BOOMERANG_STATE_RETURNING;
					}
				}
				if ((!(mighty>0))&&(AnyNPCCollision(l))){
					LweaponSetFlag(l, LWF_PENETRATING);
						state = MASTER_BOOMERANG_STATE_RETURNING;
				}
				if (range>0){
					range--;
					if (range<=0){
						expired=true;
						LweaponSetFlag(l, LWF_PENETRATING);
						state = MASTER_BOOMERANG_STATE_RETURNING;
					}
				}
			}
			else if (state == MASTER_BOOMERANG_STATE_RETURNING){
				for (int i=0; i<=3; i++){
					TriggerUpdate (l, triggers[i], SFX_SECRET, true);
				}
				int FV = Sqrt((this->Vx*this->Vx)+(this->Vy*this->Vy));
				if (FV>speed) expired = false;
				if (expired)HomingUpdate(this, 0.16, CenterLinkX(), CenterLinkY(), true);
				else HomingUpdate(this, speed, CenterLinkX(), CenterLinkY(), false);
				if (LinkCollision(l))TerminateLweapon (this, l);
			}
			soundtimer = ContiniousSFX(soundtimer, 16, SFX_BRANG);
			if (cooldown>0){
				cooldown--;
				if (cooldown<=0) l->CollDetection=true;
			}
			if (((soundtimer%4)==1)&&(cooldown==0)){
				lweapon particle;
				int lwx = this->X;
				int lwy = this->Y;
				if (sparkle>0) particle = CreateParticle (lwx, lwy, sparkle, 0, 0, 0, 0, 30, false);
				if (fire) SetAsDamagingParticle(particle, 1, 4, 4, 8, 8, NPCD_BRANG);
			}
			LweaponWaitframe (this, l, true);
		}
	} 
}

int GetFiringAngle(){
	int angle =0;
	if (Link->Dir==DIR_DOWN){
		if (Link->InputLeft) angle = 135;
		else if (Link->InputRight) angle = 45;
		else angle = 90;
	}
	else if (Link->Dir==DIR_UP){
		if (Link->InputLeft) angle = 225;
		else if (Link->InputRight) angle = 315;
		else angle = 270;
	}
	else if (Link->Dir==DIR_LEFT){
		if (Link->InputDown) angle = 135;
		else if (Link->InputUp) angle = 225;
		else angle = 180;
	}
	if (Link->Dir==DIR_RIGHT){
		if (Link->InputDown) angle = 45;
		else if (Link->InputUp) angle = 315;
		else angle = 0;
	}
	return angle;
}