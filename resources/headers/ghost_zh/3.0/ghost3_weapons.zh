// ghost.zh
// Version 3.0.0 - Alpha 9

namespace ghost3
{
	
	// EWeapon flags
	const long EWF_UNBLOCKABLE =            0000000000000001bL;  //0.0001 = 0000000000000001b
	const long EWF_ROTATE =                 0000000000000010bL;  //0.0002 = 0000000000000010b
	const long EWF_ROTATE_360 =             0000000000000100bL;  //0.0004 = 0000000000000100b
	const long EWF_SHADOW =                 0000000000001000bL;  //0.0008 = 0000000000001000b
		//4 bits
	const long EWF_FLICKER =                0000000000010000bL;  //0.0016 = 0000000000010000b
	const long EWF_NO_COLLISION =           0000000000100000bL;  //0.0032 = 0000000000100000b
	const long EWF_FAKE_Z =                 0000000001000000bL;  //0.0064 = 0000000001000000b
	const long EWF_ALIVEOFFSCREEN =         0000000010000000bL;  //0.0128 = 0000000010000000b
		//8 bits
	const long EWF_PIERCING =               0000000100000000bL;  //0.0256 = 0000000100000000b
	const long EWF_RESERVED1 =              0000001000000000bL;  //0.0512 = 0000001000000000b
	const long EWF_RESERVED2 =              0000010000000000bL;  //0.1024 = 0000010000000000b
	const long EWF_RESERVED3 =              0000100000000000bL;  //0.2048 = 0000100000000000b
		//12 bits
	const long EWF_RESERVED4 =              0001000000000000bL;  //0.4096 = 0001000000000000b
	const long EWF_RESERVED5 =              0010000000000000bL;  //0.8192 = 0010000000000000b
	const long EWF_RESERVED6 =              0100000000000000bL;  //1.6384 = 0100000000000000b
	const long EWF_RESERVED7 =              1000000000000000bL;  //3.2768 = 1000000000000000b
	//Anything past this is reserved for internal use only. See the next few constants.

	// Internal EWeapon flags
	const long EWFI_DEAD =                  00010000000000000000bL;  //6.5536 = 00010000000000000000b
	const long EWFI_DEATH_EFFECT_DONE =     00100000000000000000bL; //13.1072 = 00100000000000000000b
	
	// Arguments to SetEWeaponMovement()
	enum EW_MovementType
	{
		EWM_NONE,               //0
		EWM_SINE_WAVE,          //1
		EWM_CIRCLE_WAVE,        //2
		EWM_HOMING,             //3
		EWM_HOMING_REAIM,       //4
		EWM_RANDOM,             //5
		EWM_RANDOM_REAIM,       //6
		EWM_VEER,               //7
		EWM_WALLBOUNCE,         //8
		EWM_THROW =               15,
		EWM_THROWCHASE,         //16
		EWM_FALL =                19,
		EWM_DRIFT,              //20
		EWM_DRIFT_WAIT =          28
	};

	// Flags used by certain EWeapon movement types
	enum
	{
		EWMF_DIE =         0000001b,  //1
		EWMF_BOUNCE =      0000010b,  //2
		EWMF_KEEPMOVING =  0000010b,  //2
		EWMF_SLOWBOUNCE =  0000100b,  //4
		EWMF_SPEEDBOUNCE = 0001000b,  //8
		EWMF_SCALEUP =     0010000b,  //16
		EWMF_SCALEDOWN =   0100000b,  //32
		EWMF_REAIM =       1000000b   //64
	};

	// Arguments to SetEWeaponLifespan()
	enum
	{
		EWL_NONE,                //0
		EWL_TIMER,               //1
		EWL_NEAR_LINK,           //2
		EWL_SLOW_TO_HALT,        //3
		EWL_SHRINK,              //4
		EWL_GROW                 //5
	};

	// Arguments to SetEWeaponDeathEffect()
	enum
	{
		//0
		EWD_NONE,
		EWD_VANISH,
		EWD_AIM_AT_LINK,
		EWD_EXPLODE,
		EWD_SBOMB_EXPLODE,
		//5
		EWD_4_FIREBALLS_HV,
		EWD_4_FIREBALLS_DIAG,
		EWD_4_FIREBALLS_RANDOM,
		EWD_8_FIREBALLS,
		EWD_4_FIRES_HV,
		//10
		EWD_4_FIRES_DIAG,
		EWD_4_FIRES_RANDOM,
		EWD_8_FIRES,
		EWD_SPAWN_NPC,
		EWD_FIRE,
		//15
		EWD_RUN_SCRIPT,
		EWD_AIM_AT_P2,
		EWD_RUN_SCRIPTLW,
		EWD_RUN_SCRIPTEW
	};

	// Prototype-based version
	enum
	{
		EWD_EVEN =     1,
		EWD_RANDOM,  //2
		EWD_AIMED    //3
	};

	enum GW_INTERNAL
	{
		GWI_TRUEX,
		GWI_TRUEY,
		GWI_MOVEMENT,
		GWI_MOVEARG1,
		GWI_MOVEARG2,
		GWI_LIFESPAN,
		GWI_LIFEARG,
		GWI_DEATHTYPE,
		GWI_DEATHARG,
		GWI_FLAGS,
		GWI_MISC1,
		GWI_MISC2,
		GWI_MISC3,
		GWI_DUMMYWPN,
		GWI_DUMMYANGLE,
		GWI_DUMMYSHOTS,
		GWI_DUMMYTYPE,
		GWI_PARTICLEWPN,
		GWI_PARTICLETIMER,
		GWI_LIFEMISC,
		GWI_DEATHMISC,
		GWI_DRAWXOFFSET,
		GWI_DRAWYOFFSET,
		GWI_HITXOFFSET,
		GWI_HITYOFFSET,
		GWI_HITWIDTH,
		GWI_HITHEIGHT,
		GWI_PARTICLEOFFSET
	};

	enum
	{
		GWD_FREQ =    26,
		GWD_SFX,    //27
		GWD_STEP,   //28
		GWD_SPRITE  //29
	};

	const bool GHC_FIX_EWM_THROW = true;
	const bool GHC_FIX_EWM_FALL = true;
	const bool GHC_WEAPONS_HIT_PLATFORMS = true;
	
	
	enum GW_EXINIT //InitD Indices for dataweapons.
	{
		GWMI_INITMISC1,
		GWMI_INITMISC2,
		GWMI_INITMISC3,
		GWMI_PROTOTYPEMISC,
		GWMI_PROTOTYPESHOTS,
		GWMI_PROTOTYPEUID,
		GWMI_PARTICLEUID,
		GWMI_PARTICLETIMER,
		GWMI_INITLIFEMISC,
		GWMI_INITDEATHMISC,
		GWMI_PARTICLEOFFSET
	};
	
	const int GWM_INITSTUFF = 30; //Misc to give us more InitD's without using a thousand miscs.
	const int GWM_SETTINGS  = 31; //Misc to access internal eweapon variables.
	
	const int LW_GHOSTDEATH = 40;
	const int EW_GHOSTDEATH = 40;
	
	
	eweapon script DummyWeapon
	{
		void run(int movement, int movarg1, int movarg2, int lifespan, int lifearg, int death, int deatharg, int flags)
		{
			int args[] = {0, 0, movement, movarg1, movarg2, lifespan, lifearg, death, deatharg, flags, 0, 0, 0};
			if(movement==EWM_HOMING_REAIM || movement==EWM_RANDOM_REAIM) 
				args[GWI_MISC2]=this->Step;
			
			if(movement==EWM_THROW) args[GWI_MISC2]=this->Z;
			this->Step = 0;
			this->Misc[GWM_SETTINGS] = args;
			this->CollDetection = false;
			this->X = 32;
			this->Y = 32;
			this->DrawXOffset = -1000;
			while(true)
			{
				Waitframe();
			}
		}
	}

	eweapon script GhostWeapon
	{
		void run(int movement, int movarg1, int movarg2, int lifespan, int lifearg, int death, int deatharg, int flags)
		{
			int args[] = {this->X, this->Y, movement, movarg1, movarg2, lifespan, lifearg, death, deatharg, flags, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, this->DrawXOffset, this->DrawYOffset, this->HitXOffset, this->HitYOffset, this->HitWidth, this->HitHeight, 0};
			if (this->Misc[GWM_INITSTUFF])
			{
				lweapon data = Screen->LoadLWeaponByUID(this->Misc[GWM_INITSTUFF]);
				if (data->isValid())
				{
					args[GWI_MISC1] = data->InitD[GWMI_INITMISC1];
					args[GWI_MISC2] = data->InitD[GWMI_INITMISC2];
					args[GWI_MISC3] = data->InitD[GWMI_INITMISC3];
					args[GWI_DUMMYANGLE] = ((data->InitD[GWMI_PROTOTYPEMISC]%10)-6.2832);
					args[GWI_DUMMYTYPE]  = ((data->InitD[GWMI_PROTOTYPEMISC]-args[GWI_DUMMYANGLE])/100)>>0;
					args[GWI_DUMMYWPN]   = data->InitD[GWMI_PROTOTYPEUID];
					args[GWI_DUMMYSHOTS] = data->InitD[GWMI_PROTOTYPESHOTS];
					args[GWI_PARTICLEWPN] = data->InitD[GWMI_PARTICLEUID];
					if (data->Misc[GWM_INITSTUFF]) //Pre-empting this...
					{
						lweapon data2 = Screen->LoadLWeaponByUID(data->Misc[GWM_INITSTUFF]);
						if (data2->isValid())
						{
							args[GWI_LIFEMISC] = data2->InitD[GWMI_INITLIFEMISC-8];
							args[GWI_DEATHMISC] = data2->InitD[GWMI_INITDEATHMISC-8];
							args[GWI_PARTICLEOFFSET] = data2->InitD[GWMI_PARTICLEOFFSET-8];
						}
						Remove(data2);
					}
				}
				else this->Misc[GWM_INITSTUFF] = 0;
				Remove(data);
			}
			unless (this->Angular)
			{
				this->Angle = DegtoRad(DirAngle(this->Dir));
				this->Angular = true;
			}
			switch(movement)
			{
				case EWM_HOMING_REAIM:
				case EWM_RANDOM_REAIM:
					args[GWI_MISC2]=this->Step;
					break;
				
				case EWM_THROW:
					args[GWI_MISC2]=this->Z;
					break;
				
				case EWM_FALL:
					args[GWI_MISC2]=movarg1;
					args[GWI_MISC1]=Game->Gravity[GR_STRENGTH];
					break;
					
				default:
					break;
			}
			if (lifespan == EWL_GROW && args[GWI_LIFEMISC] == 0) args[GWI_LIFEMISC] = 0.02;
			if (lifespan == EWL_SHRINK && args[GWI_LIFEMISC] == 0) args[GWI_LIFEMISC] = -0.02;
			this->Misc[GWM_SETTINGS] = args;
			while(true)
			{
				UpdateEWeapon(this, args);
				Waitframe();
			}
		}
		// Update a weapon's movement, lifespan, and death effects
		void UpdateEWeapon(eweapon this, int args)
		{
			
			// Needed for EWF_ROTATE_360
			int startX=this->X;
			int startY=this->Y;
			bool selfPropelled=true;
			if (Abs(args[GWI_HITWIDTH]-this->HitWidth) >= 1) args[GWI_HITWIDTH] = this->HitWidth;
			if (Abs(args[GWI_HITHEIGHT]-this->HitHeight) >= 1) args[GWI_HITHEIGHT] = this->HitHeight;
			if (Abs(args[GWI_HITXOFFSET]-this->HitXOffset) >= 1) args[GWI_HITXOFFSET] = this->HitXOffset;
			if (Abs(args[GWI_HITYOFFSET]-this->HitYOffset) >= 1) args[GWI_HITYOFFSET] = this->HitYOffset;
			if (Abs(args[GWI_DRAWXOFFSET]-this->DrawXOffset) >= 1) args[GWI_DRAWXOFFSET] = this->DrawXOffset;
			if (Abs(args[GWI_DRAWYOFFSET]-this->DrawYOffset) >= 1) args[GWI_DRAWYOFFSET] = this->DrawYOffset;
			// Is the weapon still active?
			unless(args[GWI_FLAGS] & EWFI_DEAD)
			{
				if (this->X < 0 || this->Y < 0 || this->X > 240 || this->Y > 160)
				{
					if (args[GWI_FLAGS] & EWF_ALIVEOFFSCREEN)
					{
						this->DeadState = WDS_ALIVE;
					}
				}
				else if (args[GWI_FLAGS] & EWF_PIERCING) this->DeadState = WDS_ALIVE;
				DoEWeaponParticles(this, args);
				// Start movement updates
				if(args[GWI_MOVEMENT]!=0)
				{
					switch(args[GWI_MOVEMENT])
					{
						case EWM_SINE_WAVE:
							UpdateEWMSineWave(this, args);
							break;
						case EWM_CIRCLE_WAVE:
							UpdateEWMCircleWave(this, args);
							break;
						case EWM_HOMING:
							UpdateEWMHoming(this, args);
							break;
						case EWM_HOMING_REAIM:
							UpdateEWMHomingReaim(this, args);
							break;
						case EWM_RANDOM:
							UpdateEWMRandom(this, args);
							break;
						case EWM_RANDOM_REAIM:
							UpdateEWMRandomReaim(this, args);
							break;
						case EWM_VEER:
							startX=args[GWI_TRUEX];
							startY=args[GWI_TRUEY];
							UpdateEWMVeer(this, args);
							selfPropelled=false;
							break;
							
						case EWM_WALLBOUNCE:
							startX=args[GWI_TRUEX];
							startY=args[GWI_TRUEY];
							UpdateEWMWallBounce(this, args);
							selfPropelled=false;
							break;

						case EWM_THROW:
							UpdateEWMThrow(this, args);
							break;
						case EWM_THROWCHASE:
							UpdateEWMThrowChase(this, args);
							break;
						case EWM_FALL:
							UpdateEWMFall(this, args);
							break;
						case EWM_DRIFT:
							startX=args[GWI_TRUEX];
							startY=args[GWI_TRUEY];
							UpdateEWMDrift(this, args);
							selfPropelled=false;
							break;
				
						case EWM_DRIFT_WAIT:
							startX=args[GWI_TRUEX];
							startY=args[GWI_TRUEY];
							UpdateEWMDriftWait(this, args);
							selfPropelled=false;
							break;
						
						default:
							break;
					}
				} // End movement updates
				
				
				// Start lifespan updates
				if(args[GWI_LIFESPAN]!=0)
				{
					switch(args[GWI_LIFESPAN])
					{
						case EWL_TIMER:
						{
							args[GWI_LIFEARG]-=1;
							if(args[GWI_LIFEARG]<=0)
								KillEWeapon(this);
							break;
						}
						case EWL_NEAR_LINK:
						{
							if(Distance(this->X, this->Y, Link->X, Link->Y)<args[GWI_LIFEARG])
								KillEWeapon(this);
							break;
						}
						case EWL_SLOW_TO_HALT:
						{
							this->Step=Max(0, this->Step-args[GWI_LIFEARG]);
							if(this->Step<=0)
								KillEWeapon(this);
							break;
						}
						case EWL_GROW:
						case EWL_SHRINK:
						{
							args[GWI_LIFEARG]-=1;
							if(args[GWI_LIFEARG]==0)
								KillEWeapon(this);
							else
							{
								int diff = args[GWI_HITWIDTH];
								args[GWI_HITWIDTH] *= (1+args[GWI_LIFEMISC]);
								args[GWI_HITXOFFSET] -= (args[GWI_HITWIDTH]-diff)/2;
								args[GWI_DRAWXOFFSET] -= (args[GWI_HITWIDTH]-diff)/2;
								diff = args[GWI_HITHEIGHT];
								args[GWI_HITHEIGHT] *= (1+args[GWI_LIFEMISC]);
								args[GWI_HITYOFFSET] -= (args[GWI_HITHEIGHT]-diff)/2;
								args[GWI_DRAWYOFFSET] -= (args[GWI_HITHEIGHT]-diff)/2;
								if (this->Scale == 0) this->Scale = 1;
								this->Scale *= (1+args[GWI_LIFEMISC]);
							}
							break;
						}
						default:
							break;
					}
				} // End lifespan updates
			}

			// Start death effects
			else if(args[GWI_DEATHTYPE] && !(args[GWI_FLAGS] & EWFI_DEATH_EFFECT_DONE))
			{
				if(args[GWI_DEATHTYPE]<0)
					DoEWeaponDeathPrototype(this, args);

				// Split in half to reduce checks
				switch(args[GWI_DEATHTYPE])
				{
					case EWD_VANISH:
						this->DeadState=0;
						break;
					case EWD_AIM_AT_LINK:
						DoEWeaponDeathAimAtLink(this, args);
						break;
					case EWD_EXPLODE:
						DoEWeaponDeathExplode(this, args);
						break;
					case EWD_SBOMB_EXPLODE:
						DoEWeaponDeathSBombExplode(this, args);
						break;
					case EWD_4_FIREBALLS_HV:
						DoEWeaponDeath4FireballsHV(this, args);
						break;
					case EWD_4_FIREBALLS_DIAG:
						DoEWeaponDeath4FireballsDiag(this, args);
						break;
					case EWD_4_FIREBALLS_RANDOM:
						DoEWeaponDeath4FireballsRand(this, args);
						break;
					case EWD_8_FIREBALLS:
						DoEWeaponDeath8Fireballs(this, args);
						break;
					case EWD_4_FIRES_HV:
						DoEWeaponDeath4FiresHV(this, args);
						break;
					case EWD_4_FIRES_DIAG:
						DoEWeaponDeath4FiresDiag(this, args);
						break;
					case EWD_4_FIRES_RANDOM:
						DoEWeaponDeath4FiresRand(this, args);
						break;
					case EWD_8_FIRES:
						DoEWeaponDeath8Fires(this, args);
						break;
					case EWD_SPAWN_NPC:
						DoEWeaponDeathSpawnNPC(this, args);
						break;
					case EWD_FIRE:
						DoEWeaponDeathSingleFire(this, args);
						break;
					case EWD_RUN_SCRIPT:
						DoEWeaponDeathRunScriptFFC(this, args);
						break;
					case EWD_RUN_SCRIPTLW:
						DoEWeaponDeathRunScriptLWeapon(this, args);
						break;
					case EWD_RUN_SCRIPTEW:
						DoEWeaponDeathRunScriptEWeapon(this, args);
						break;
				}
			} // End death effects
			
			this->HitWidth = Round(args[GWI_HITWIDTH]);
			this->HitHeight = Round(args[GWI_HITHEIGHT]);
			this->HitXOffset = Round(args[GWI_HITXOFFSET]);
			this->HitYOffset = Round(args[GWI_HITYOFFSET]);
			this->DrawXOffset = Round(args[GWI_DRAWXOFFSET]);
			this->DrawYOffset = Round(args[GWI_DRAWYOFFSET]);
			
			// Start flags
			
			if(args[GWI_FLAGS] & EWF_ROTATE_360)
			{
				this->DrawXOffset=1000;
				
				// Don't draw if Link is dead
				if(Link->HP<=0)
					return;
				
				// Flickering? Nothing to do here.
				if((args[GWI_FLAGS] & EWF_FLICKER) &&
				   (Game->Time & 10bL))
					return;
				
				float endX;
				float endY;
				float angle;
				
				// Get the angle first
				if(this->Angular)
					angle=RadtoDeg(this->Angle);
				else
				{
					int dir=NormalizeDir(this->Dir);
					
					if(dir==DIR_UP)
						angle=-90;
					else if(dir==DIR_RIGHTUP)
						angle=-45;
					else if(dir==DIR_RIGHT)
						angle=0;
					else if(dir==DIR_RIGHTDOWN)
						angle=45;
					else if(dir==DIR_DOWN)
						angle=90;
					else if(dir==DIR_LEFTDOWN)
						angle=135;
					else if(dir==DIR_LEFT)
						angle=180;
					else // DIR_LEFTUP
						angle=-135;
				}
				
				if(selfPropelled)
				{
					endX=this->X+this->Step/100*Cos(angle);
					endY=this->Y+this->Step/100*Sin(angle);
				}
				else
				{
					endX=args[GWI_TRUEX];
					endY=args[GWI_TRUEY];
				}
				
				// If the weapon's moving, use that angle instead of
				// this->Angle or this->Dir
				if(!(startX==endX && startY==endY))
					angle=Angle(startX, startY, endX, endY);
				
				int flip;
				if(angle>=0 && angle<180)
					flip=0;
				else
					flip=2;
				
				// Currently, these are always drawn on layer 4.
				// That should probably be changed...
				if (this->Scale != 0)
				{
					int scalexoffset = (this->TileWidth - (this->TileWidth*this->Scale))/2;
					int scaleyoffset = (this->TileHeight - (this->TileHeight*this->Scale))/2;
					Screen->DrawTile(4, endX+scalexoffset, endY-this->Z+scaleyoffset, this->Tile,
					  this->TileWidth, this->TileHeight, this->CSet, this->TileWidth*this->Scale, this->TileHeight*this->Scale,
					  endX, endY-this->Z, angle, flip, true, OP_OPAQUE);
				}
				else
				{
					Screen->DrawTile(4, endX, endY-this->Z, this->Tile,
						  this->TileWidth, this->TileHeight, this->CSet, -1, -1,
						  endX, endY-this->Z, angle, flip, true, OP_OPAQUE);
				}
			}
			else // EWF_ROTATE_360 isn't set
			{
				if(args[GWI_FLAGS] & EWF_FLICKER)
				{
					// Weapons can't be made invisible; use DrawXOffset instead
					if(Game->Time & 10bL)
						this->DrawXOffset=1000;
					else
						this->DrawXOffset=0;
				}
				
				if(args[GWI_FLAGS] & EWF_ROTATE)
					SetEWeaponRotation(this);
			}
			
			if((args[GWI_FLAGS] & EWF_FAKE_Z) || Game->Ghost[GHV_FAKE_EWEAPON_Z])
			{
				// For some reason, DrawZOffset is also HitZOffset,
				// so Y offsets also have to be used.
				this->DrawZOffset=-this->Z;
				this->HitYOffset=-this->Z;
				this->DrawYOffset=-this->Z;
			}
			
			// End flags
		}
		void UpdateEWMSineWave(eweapon this, int args)
		{
			args[GWI_MISC1] += args[GWI_MOVEARG2];

			// Adjust the weapon's position at an angle
			// perpendicular to that of its forward movement.
			int offset=args[GWI_MOVEARG1]*Sin(args[GWI_MISC1]);
			args[GWI_TRUEX]+=(this->Step/100)*RadianCos(this->Angle);
			args[GWI_TRUEY]+=(this->Step/100)*RadianSin(this->Angle);
			this->X=args[GWI_TRUEX]+offset*RadianCos(this->Angle+1.5708);
			this->Y=args[GWI_TRUEY]+offset*RadianSin(this->Angle+1.5708);
		}
		void UpdateEWMCircleWave(eweapon this, int args)
		{
			args[GWI_MISC1] += args[GWI_MOVEARG2];

			//Circling weapon goes wheee
			//Years later someone's gonna dig down here and find this comment
			//Presumably because this function bugged out in a way I did not intend.
			//They're gonna get very angry that I just left this comment here
			//Instead of something helpful. :D :D :D
			args[GWI_TRUEX]+=(this->Step/100)*RadianCos(this->Angle);
			args[GWI_TRUEY]+=(this->Step/100)*RadianSin(this->Angle);
			this->X=args[GWI_TRUEX]+args[GWI_MOVEARG1]*Cos(args[GWI_MISC1]);
			this->Y=args[GWI_TRUEY]+args[GWI_MOVEARG1]*Sin(args[GWI_MISC1]);
		}
		void UpdateEWMHoming(eweapon this, int args)
		{
			// Wrap angle to 0..2*PI
			float currentAngle=this->Angle%6.2832;

			if(currentAngle<0)
			currentAngle+=6.2832;

			// Find angle to Link and wrap it
			float targetAngle=RadianAngle(this->X, this->Y, Link->X, Link->Y);
			if(targetAngle<0)
			targetAngle+=6.2832;

			float diff=Abs(currentAngle-targetAngle);

			// Turn toward Link
			if(diff<args[GWI_MOVEARG1] || diff>6.2832-args[GWI_MOVEARG1])
			this->Angle=targetAngle;

			// Can't turn enough to point directly at him...
			else if(Sign(currentAngle-targetAngle)==Sign(diff-PI)) // current>target and diff>pi or
			this->Angle+=args[GWI_MOVEARG1]; // current<target and diff<pi
			else   // - Turn CW or CCW?
			this->Angle-=args[GWI_MOVEARG1];

			SetEWeaponDir(this);

			// Decrement timer, unless it was negative to begin with
			if(args[GWI_MOVEARG2]>0)
			{
				args[GWI_MOVEARG2]--;
				if(args[GWI_MOVEARG2]<=0)
				KillEWeapon(this);
			}
		}
		void UpdateEWMHomingReaim(eweapon this, int args)
		{
			// Set time before re-aiming
			if(args[GWI_MISC1]==0)
				args[GWI_MISC1]=args[GWI_MOVEARG2];
			
			if(args[GWI_MISC1]>0) // If positive, this is moving
			{
				args[GWI_MISC1]--;
				if(args[GWI_MISC1]==0)
				{
					if(args[GWI_MOVEARG1]<=0) // No more aims left
						KillEWeapon(this);

					else // Stop
					{
						args[GWI_MOVEARG1]--;
						this->Step=0;
						args[GWI_MISC1]=-20;
					}
				}
			}
			else // If negative, it's stopped to aim
			{
				args[GWI_MISC1]++;
				// Spin in place while waiting
				if(args[GWI_FLAGS] & EWF_ROTATE_360)
					this->Angle+=0.3;
				else if(args[GWI_FLAGS] & EWF_ROTATE)
				{
					this->Angle+=0.2;
					// Pick the direction based on the timer
					int dir=-args[GWI_MISC1]&110b;

					if(dir==110b)
						SetEWeaponRotation(this, DIR_UP);
					else if(dir==100b)
						SetEWeaponRotation(this, DIR_RIGHT);
					else if(dir==010b)
						SetEWeaponRotation(this, DIR_DOWN);
					else
						SetEWeaponRotation(this, DIR_LEFT);
				}
				unless(args[GWI_MISC1]) // Start up again
				{
					args[GWI_MISC1]=45;
					this->Angle=RadianAngle(this->X, this->Y, Link->X, Link->Y);
					this->Step=args[GWI_MISC2];
					SetEWeaponDir(this);
					if(args[GWI_FLAGS] & EWF_ROTATE)
						SetEWeaponRotation(this);
				}
			}
		}
		
		void UpdateEWMRandom(eweapon this, int args)
		{
			this->Angle+=Randf(2*args[GWI_MOVEARG1])-args[GWI_MOVEARG1];
			SetEWeaponDir(this);
			if(args[GWI_FLAGS] & EWF_ROTATE)
				SetEWeaponRotation(this);
			
			// Update the timer
			if(args[GWI_MOVEARG2]>0)
			{
				args[GWI_MOVEARG2]--;
				if(args[GWI_MOVEARG2]<=0)
					KillEWeapon(this);
			}
		}
		
		void UpdateEWMRandomReaim(eweapon this, int args)
		{
			// Set movement time
			if(args[GWI_MISC1]==0)
				args[GWI_MISC1]=args[GWI_MOVEARG2];

			if(args[GWI_MISC1]>0) // If positive, this is moving
			{
				args[GWI_MISC1]--;
				if(args[GWI_MISC1]==0)
				{
					if(args[GWI_MOVEARG1]<=0) // No more aims left
						KillEWeapon(this);
					else // Stop
					{
						args[GWI_MOVEARG1]--;
						this->Step=0;
						args[GWI_MISC1]=-20;
					}
				}

			}
			else // If negative, it's stopped to aim
			{
				args[GWI_MISC1]++;
				if(args[GWI_MISC1]==0) // Start up again
				{
					args[GWI_MISC1]=45;
					this->Angle=Rand(62832)*0.0001;
					this->Step=args[GWI_MISC2];
					SetEWeaponDir(this);
					if(args[GWI_FLAGS] & EWF_ROTATE)
						SetEWeaponRotation(this);
				}
				// Spin in place while waiting
				if(args[GWI_FLAGS] & EWF_ROTATE_360)
					this->Angle+=0.3;
				else if(args[GWI_FLAGS] & EWF_ROTATE)
				{
					// Pick the direction based on the timer
					int dir=-args[GWI_MISC1]&110b;
					
					if(dir==110b)
						SetEWeaponRotation(this, DIR_UP);
					else if(dir==100b)
						SetEWeaponRotation(this, DIR_RIGHT);
					else if(dir==010b)
						SetEWeaponRotation(this, DIR_DOWN);
					else
						SetEWeaponRotation(this, DIR_LEFT);
				}
			}
		}

		void UpdateEWMVeer(eweapon this, int args)
		{
			// Override regular movement
			int dir=args[GWI_MOVEARG1];
			args[GWI_TRUEX]+=(this->Step/100)*RadianCos(this->Angle);
			args[GWI_TRUEY]+=(this->Step/100)*RadianSin(this->Angle);
			
			if(dir==DIR_UP)
				args[GWI_TRUEY]-=args[GWI_MISC1];
			else if(dir==DIR_DOWN)
				args[GWI_TRUEY]+=args[GWI_MISC1];
			else if(dir==DIR_LEFT)
				args[GWI_TRUEX]-=args[GWI_MISC1];
			else if(dir==DIR_RIGHT)
				args[GWI_TRUEX]+=args[GWI_MISC1];
			else if(dir==DIR_LEFTUP)
			{
				args[GWI_TRUEX]-=args[GWI_MISC1]*DIAGONAL_MODIFIER;
				args[GWI_TRUEY]-=args[GWI_MISC1]*DIAGONAL_MODIFIER;
			}
			else if(dir==DIR_RIGHTUP)
			{
				args[GWI_TRUEX]+=args[GWI_MISC1]*DIAGONAL_MODIFIER;
				args[GWI_TRUEY]-=args[GWI_MISC1]*DIAGONAL_MODIFIER;
			}
			else if(dir==DIR_LEFTDOWN)
			{
				args[GWI_TRUEX]-=args[GWI_MISC1]*DIAGONAL_MODIFIER;
				args[GWI_TRUEY]+=args[GWI_MISC1]*DIAGONAL_MODIFIER;
			}
			else // DIR_RIGHTDOWN
			{
				args[GWI_TRUEX]+=args[GWI_MISC1]*DIAGONAL_MODIFIER;
				args[GWI_TRUEY]+=args[GWI_MISC1]*DIAGONAL_MODIFIER;
			}

			this->X=args[GWI_TRUEX];
			this->Y=args[GWI_TRUEY];
			args[GWI_MISC1]+=args[GWI_MOVEARG2];
		}
		
		void UpdateEWMWallBounce(eweapon this, int args)
		{
			// Override regular movement
			int xpush = (this->Step/100)*RadianCos(this->Angle);
			int ypush = (this->Step/100)*RadianSin(this->Angle);
			int xpush3 = xpush;
			int ypush3 = ypush;
			int signx = Sign(xpush);
			int signy = Sign(ypush);
			//args[GWI_TRUEX]+=(this->Step/100)*RadianCos(this->Angle);
			//args[GWI_TRUEY]+=(this->Step/100)*RadianSin(this->Angle);
			while (xpush != 0 || ypush != 0)
			{
				if (Sign(xpush)) signx = Sign(xpush);
				if (Sign(ypush)) signy = Sign(ypush);
				unless (CanWalk(args[GWI_TRUEX], args[GWI_TRUEY], ghost3::AngleDir4(0, 0, signx, 0), 1, false)) 
				{
					unless (args[GWI_MOVEARG1] == 0) 
					{
						signx *= -1;
						if (args[GWI_MOVEARG2]&EWMF_SPEEDBOUNCE) 
						{
							if (args[GWI_MOVEARG2]&EWMF_SLOWBOUNCE) 
							{
								this->Step *= 1.25;
							}
							else 
							{
								this->Step *= 1.5;
							}
						}
						else if (args[GWI_MOVEARG2]&EWMF_SLOWBOUNCE)
						{
							if (this->Step <= 75 && (args[GWI_MOVEARG2]&EWMF_DIE) && args[GWI_MOVEARG1] < 0) KillEWeapon(this);
							else 
							{
								this->Step /= 1.5;
							}
						}
						if (args[GWI_MOVEARG2]&EWMF_SCALEUP)
						{
							int diff = args[GWI_HITWIDTH];
							args[GWI_HITWIDTH] *= 1.25;
							args[GWI_HITXOFFSET] -= (args[GWI_HITWIDTH]-diff)/2;
							args[GWI_DRAWXOFFSET] -= (args[GWI_HITWIDTH]-diff)/2;
							diff = args[GWI_HITHEIGHT];
							args[GWI_HITHEIGHT] *= 1.25;
							args[GWI_HITYOFFSET] -= (args[GWI_HITHEIGHT]-diff)/2;
							args[GWI_DRAWYOFFSET] -= (args[GWI_HITHEIGHT]-diff)/2;
							if (this->Scale == 0) this->Scale = 1;
							this->Scale *= 1.25;
						}
						if (args[GWI_MOVEARG2]&EWMF_SCALEDOWN)
						{
							int diff = args[GWI_HITWIDTH];
							args[GWI_HITWIDTH] /= 1.25;
							args[GWI_HITXOFFSET] -= (args[GWI_HITWIDTH]-diff)/2;
							args[GWI_DRAWXOFFSET] -= (args[GWI_HITWIDTH]-diff)/2;
							diff = args[GWI_HITHEIGHT];
							args[GWI_HITHEIGHT] /= 1.25;
							args[GWI_HITYOFFSET] -= (args[GWI_HITHEIGHT]-diff)/2;
							args[GWI_DRAWYOFFSET] -= (args[GWI_HITHEIGHT]-diff)/2;
							if (this->Scale == 0) this->Scale = 1;
							this->Scale /= 1.25;
						}
						if (args[GWI_MOVEARG1] > 0) --args[GWI_MOVEARG1];
					}
					else
					{
						if(args[GWI_MOVEARG2]&EWMF_DIE) KillEWeapon(this);
						unless(args[GWI_MOVEARG2]&EWMF_KEEPMOVING)
						{
							this->Step=0;
						}
						args[GWI_MOVEMENT]=0;
					}
				}
				if (args[GWI_MOVEARG2]&EWMF_REAIM) break;
				int xpush2 = signx*Min(1, Abs(xpush));
				if (CanWalk(args[GWI_TRUEX], args[GWI_TRUEY], ghost3::AngleDir4(0, 0, signx, 0), 1, false)) args[GWI_TRUEX]+=xpush2;
				
				unless (CanWalk(args[GWI_TRUEX], args[GWI_TRUEY], ghost3::AngleDir4(0, 0, 0, signy), 1, false)) 
				{
					unless (args[GWI_MOVEARG1] == 0) //Zoria: "can this ever be < 0 and be safe?" Dimi: "Yes, don't bloody touch it. < 0 means it bounces until it dies some other way."
					{
						signy *= -1;
						if (args[GWI_MOVEARG2]&EWMF_SPEEDBOUNCE) 
						{
							if (args[GWI_MOVEARG2]&EWMF_SLOWBOUNCE) 
							{
								this->Step *= 1.25;
							}
							else 
							{
								this->Step *= 1.5;
							}
						}
						else if (args[GWI_MOVEARG2]&EWMF_SLOWBOUNCE)
						{
							if (this->Step <= 75 && (args[GWI_MOVEARG2]&EWMF_DIE) && args[GWI_MOVEARG1] < 0) KillEWeapon(this);
							else 
							{
								this->Step /= 1.5;
							}
						}
						if (args[GWI_MOVEARG2]&EWMF_SCALEUP)
						{
							int diff = args[GWI_HITWIDTH];
							args[GWI_HITWIDTH] *= 1.25;
							args[GWI_HITXOFFSET] -= (args[GWI_HITWIDTH]-diff)/2;
							args[GWI_DRAWXOFFSET] -= (args[GWI_HITWIDTH]-diff)/2;
							diff = args[GWI_HITHEIGHT];
							args[GWI_HITHEIGHT] *= 1.25;
							args[GWI_HITYOFFSET] -= (args[GWI_HITHEIGHT]-diff)/2;
							args[GWI_DRAWYOFFSET] -= (args[GWI_HITHEIGHT]-diff)/2;
							if (this->Scale == 0) this->Scale = 1;
							this->Scale *= 1.25;
						}
						if (args[GWI_MOVEARG2]&EWMF_SCALEDOWN)
						{
							int diff = args[GWI_HITWIDTH];
							args[GWI_HITWIDTH] /= 1.25;
							args[GWI_HITXOFFSET] -= (args[GWI_HITWIDTH]-diff)/2;
							args[GWI_DRAWXOFFSET] -= (args[GWI_HITWIDTH]-diff)/2;
							diff = args[GWI_HITHEIGHT];
							args[GWI_HITHEIGHT] /= 1.25;
							args[GWI_HITYOFFSET] -= (args[GWI_HITHEIGHT]-diff)/2;
							args[GWI_DRAWYOFFSET] -= (args[GWI_HITHEIGHT]-diff)/2;
							if (this->Scale == 0) this->Scale = 1;
							this->Scale /= 1.25;
						}
						if (args[GWI_MOVEARG1] > 0) --args[GWI_MOVEARG1];
					}
					else
					{
						if(args[GWI_MOVEARG2]&EWMF_DIE) ghost3::KillEWeapon(this);
						unless(args[GWI_MOVEARG2]&EWMF_KEEPMOVING)
						{
							this->Step=0;
						}
						args[GWI_MOVEMENT]=0;
					}
				}
				if (args[GWI_MOVEARG2]&EWMF_REAIM) break;
				int ypush2 = signy*Min(1, Abs(ypush));
				if (CanWalk(args[GWI_TRUEX], args[GWI_TRUEY], ghost3::AngleDir4(0, 0, 0, signy), 1, false)) args[GWI_TRUEY]+=ypush2;
				ypush = signy*(Abs(ypush)-Abs(ypush2));
				xpush = signx*(Abs(xpush)-Abs(xpush2));
			}
			if (args[GWI_MOVEARG2]&EWMF_REAIM) this->Angle = RadianAngle(args[GWI_TRUEX], args[GWI_TRUEY], Hero->X, Hero->Y);
			else this->Angle = RadianAngle(0, 0, (signx * Abs(xpush3)), (signy * Abs(ypush3)));
			this->X=args[GWI_TRUEX];
			this->Y=args[GWI_TRUEY];
		}

		void UpdateEWMThrow(eweapon this, int args)
		{
			// GWI_MISC1: Current jump
			// GWI_MISC2: Current Z position
			// GWI_MOVEARG1: Initial jump
			// GWI_MOVEARG2: Flags
			
			this->Jump=0; // Override engine handling of Z movement
			
			// Just thrown
			if(args[GWI_MISC1]==0 && args[GWI_MOVEARG1]!=0)
			{
				args[GWI_MISC1]=args[GWI_MOVEARG1];
				args[GWI_MOVEARG1]=0;
			}
			
			// Fall
			args[GWI_MISC2]=Max(args[GWI_MISC2]+args[GWI_MISC1], 0);
			if(GHC_FIX_EWM_THROW)
			{
				unless(IsSideview())
				{
					this->Z=args[GWI_MISC2];
				}
				else
				{
					this->Y = 176-args[GWI_MISC2];
				}
			}
			else
			{
				this->Y = 176-args[GWI_MISC2];
			}
			
			// Still in the air; adjust velocity
			if(args[GWI_MISC2] > 0 )
			{
				if(GHC_WEAPONS_HIT_PLATFORMS)
				{
					if (!ghost3::OnSidePlatform(this->X, this->Y, 
									this->HitXOffset,
									this->HitYOffset, 
									this->HitHeight,this->HitWidth)
					)
					{
						args[GWI_MISC1]=Max(args[GWI_MISC1]-Game->Gravity[GR_STRENGTH], -Game->Gravity[GR_TERMINALV]);
					}
				}
				else 
				{
					args[GWI_MISC1]=Max(args[GWI_MISC1]-Game->Gravity[GR_STRENGTH], -Game->Gravity[GR_TERMINALV]);
				}
			}
			
			// Hit the ground
			else
			{
				bool done=false;
				
				// Bounce
				if((args[GWI_MOVEARG2]&EWMF_BOUNCE))
				{
					// Falling fast enough?
					if(args[GWI_MISC1]<-0.5) // Jump<=-0.5
					{
						args[GWI_MISC1]*=-0.5;
						this->Step*=0.75;
					}
					// Not fast enough
					else
					{
						done=true;
					}
				}
				// Don't bounce
				else
				{
					done=true;
				}
				// Movement ended; stop or die?
				if(done)
				{
					if((args[GWI_MOVEARG2]&EWMF_DIE))
					{
						this->Z=0;
						KillEWeapon(this);
					}
					else
					{
						args[GWI_MOVEMENT]=0;
						this->Step=0;
					}
				}
			}
		}
		
		void UpdateEWMThrowChase(eweapon this, int args)
		{
			// GWI_MISC1: Current jump
			// GWI_MISC2: Current Z position
			// GWI_MISC3: Stored Step
			// GWI_MOVEARG1: Initial jump
			// GWI_MOVEARG2: Repeat jumps
			
			
			bool justinit = false;
			
			this->Jump=0; // Override engine handling of Z movement
			
			// Just thrown
			if(args[GWI_MISC1]==0 && args[GWI_MOVEARG1]>0)
			{
				args[GWI_MISC1]=args[GWI_MOVEARG1];
				args[GWI_MOVEARG1] *= -1;
				justinit = true;
			}
			
			// Fall
			if (args[GWI_MISC2] > 0 || args[GWI_MISC1] > 0) args[GWI_MISC2]=Max(args[GWI_MISC2]+args[GWI_MISC1], 0);
			if(GHC_FIX_EWM_THROW)
			{
				unless(IsSideview())
				{
					this->Z=args[GWI_MISC2];
				}
				else
				{
					this->Y = 176-args[GWI_MISC2];
				}
			}
			else
			{
				this->Y = 176-args[GWI_MISC2];
			}
			
			// Still in the air; adjust velocity
			if(args[GWI_MISC2] > 0 )
			{
				if(GHC_WEAPONS_HIT_PLATFORMS)
				{
					if (!ghost3::OnSidePlatform(this->X, this->Y, 
									this->HitXOffset,
									this->HitYOffset, 
									this->HitHeight,this->HitWidth)
					)
					{
						args[GWI_MISC1]=Max(args[GWI_MISC1]-Game->Gravity[GR_STRENGTH], -Game->Gravity[GR_TERMINALV]);
					}
				}
				else 
				{
					args[GWI_MISC1]=Max(args[GWI_MISC1]-Game->Gravity[GR_STRENGTH], -Game->Gravity[GR_TERMINALV]);
				}
			}
			
			// Hit the ground
			else unless(justinit)
			{
				bool done=false;
				
				if(args[GWI_MOVEARG2] > 0)
				{
					if (this->Step > 0)
					{
						unless (args[GWI_MISC3]) args[GWI_MISC3] = this->Step;
						this->Step = 0;
					}
					--args[GWI_MISC2];
					if (args[GWI_MISC2] <= -30)
					{
						--args[GWI_MOVEARG2];
						args[GWI_MISC1] = Abs(args[GWI_MOVEARG1]);
						args[GWI_MISC2] = 0;
						this->Angle = DegtoRad(Angle(this->X, this->Y, Hero->X, Hero->Y));
						this->Step = args[GWI_MISC3];
						args[GWI_MISC3] = 0;
					}
				}
				// Don't bounce
				else
				{
					done=true;
				}
				// Movement ended; stop or die?
				if(done)
				{
					this->Z=0;
					KillEWeapon(this);
				}
			}
		}

		void UpdateEWMFall(eweapon this, int args)
		{
			this->Jump=0; // Override engine handling of Z movement
			args[GWI_MISC2]-=args[GWI_MISC1];
			if(GHC_FIX_EWM_FALL)
			{
				unless(IsSideview())	
				{
					this->Z=args[GWI_MISC2];
				}
				else
				{
					this->HitYOffset= args[GWI_MISC2];
					this->DrawYOffset=args[GWI_MISC2];
				}
				args[GWI_MISC1]=Min(args[GWI_MISC1]+Game->Gravity[GR_STRENGTH], Game->Gravity[GR_TERMINALV]);
			}
			else
			{
				this->Z=args[GWI_MISC2];
				args[GWI_MISC1]=Min(args[GWI_MISC1]+Game->Gravity[GR_STRENGTH], Game->Gravity[GR_TERMINALV]);
			}
			
			// Hit the ground?
			if(GHC_WEAPONS_HIT_PLATFORMS)
			{
				if ( args[GWI_MISC2] <=0 )
				{
					unless(ghost3::OnSidePlatform(this->X, this->Y, 
									this->HitXOffset,
									this->HitYOffset, 
									this->HitHeight,this->HitWidth)
					)
					{
						bool done=false;
				
						// Bounce
						if((args[GWI_MOVEARG2]&EWMF_BOUNCE)!=0)
						{
							// Falling fast enough?
							if(args[GWI_MISC1]<-0.5) // Jump<=-0.5
							{
								args[GWI_MISC1]*=-0.5;
								this->Step*=0.75;
							}
							// Not fast enough
							else
							{
								done=true;
							}
						}
						// Don't bounce
						else
						{
							done=true;
						}
						// Movement ended; stop or die?
						if(done)
						{
							if((args[GWI_MOVEARG2]&EWMF_DIE))
							{
								this->Z=0;
								KillEWeapon(this);
							}
							else
							{
								args[GWI_MOVEMENT]=0;
								this->Step=0;
							}
						}
					}
				}
			}
			else
			{
				if(args[GWI_MISC2]<=0)
				{
					bool done=false;
				
					// Bounce
					if((args[GWI_MOVEARG2]&EWMF_BOUNCE))
					{
						// Falling fast enough?
						if(args[GWI_MISC1]<-0.5) // Jump<=-0.5
						{
							args[GWI_MISC1]*=-0.5;
							this->Step*=0.75;
						}
						// Not fast enough
						else
						{
							done=true;
						}
					}
					// Don't bounce
					else
					{
						done=true;
					}
					// Movement ended; stop or die?
					if(done)
					{
						if((args[GWI_MOVEARG2]&EWMF_DIE))
						{
							this->Z=0;
							KillEWeapon(this);
						}
						else
						{
							args[GWI_MOVEMENT]=0;
							this->Step=0;
						}
					}
				}
			}
		}

		void UpdateEWMDrift(eweapon this, int args)
		{
			int dir=args[GWI_MOVEARG1];
			
			// Override regular movement
			args[GWI_TRUEX]+=(this->Step/100)*RadianCos(this->Angle);
			args[GWI_TRUEY]+=(this->Step/100)*RadianSin(this->Angle);
			
			// Drifting
			if(dir==DIR_UP)
				args[GWI_TRUEY]-=args[GWI_MOVEARG2];
			else if(dir==DIR_DOWN)
				args[GWI_TRUEY]+=args[GWI_MOVEARG2];
			else if(dir==DIR_LEFT)
				args[GWI_TRUEX]-=args[GWI_MOVEARG2];
			else if(dir==DIR_RIGHT)
				args[GWI_TRUEX]+=args[GWI_MOVEARG2];
			else if(dir==DIR_LEFTUP)
			{
				args[GWI_TRUEX]-=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
				args[GWI_TRUEY]-=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
			}
			else if(dir==DIR_RIGHTUP)
			{
				args[GWI_TRUEX]+=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
				args[GWI_TRUEY]-=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
			}
			else if(dir==DIR_LEFTDOWN)
			{
				args[GWI_TRUEX]-=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
				args[GWI_TRUEY]+=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
			}
			else // DIR_RIGHTDOWN
			{
				args[GWI_TRUEX]+=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
				args[GWI_TRUEY]+=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
			}
			
			this->X=args[GWI_TRUEX];
			this->Y=args[GWI_TRUEY];
		}

		void UpdateEWMDriftWait(eweapon this, int args)
		{
			int dir=args[GWI_MOVEARG1];
			
			// Is the weapon moving? Override its regular movement if so
			if(args[GWI_MISC1]>=16)
			{
				args[GWI_TRUEX]+=(this->Step/100)*RadianCos(this->Angle);
				args[GWI_TRUEY]+=(this->Step/100)*RadianSin(this->Angle);
			}
			
			// If not, just drift in place
			else
				args[GWI_MISC1]++;
			
			// Drifting
			if(dir==DIR_UP)
				args[GWI_TRUEY]-=args[GWI_MOVEARG2];
			else if(dir==DIR_DOWN)
				args[GWI_TRUEY]+=args[GWI_MOVEARG2];
			else if(dir==DIR_LEFT)
				args[GWI_TRUEX]-=args[GWI_MOVEARG2];
			else if(dir==DIR_RIGHT)
				args[GWI_TRUEX]+=args[GWI_MOVEARG2];
			else if(dir==DIR_LEFTUP)
			{
				args[GWI_TRUEX]-=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
				args[GWI_TRUEY]-=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
			}
			else if(dir==DIR_RIGHTUP)
			{
				args[GWI_TRUEX]+=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
				args[GWI_TRUEY]-=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
			}
			else if(dir==DIR_LEFTDOWN)
			{
				args[GWI_TRUEX]-=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
				args[GWI_TRUEY]+=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
			}
			else // DIR_RIGHTDOWN
			{
				args[GWI_TRUEX]+=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
				args[GWI_TRUEY]+=args[GWI_MOVEARG2]*DIAGONAL_MODIFIER;
			}
			
			this->X=args[GWI_TRUEX];
			this->Y=args[GWI_TRUEY];
		}
		void DoEWeaponDeathPrototype(eweapon this, int args)
		{
			int id;
			eweapon prototype;
			eweapon newWpn;
			int spreadType;
			int centerX;
			int centerY;
			float angle;
			int numShots;
			int i;

			// Find the prototype
			id=args[GWI_DUMMYWPN];
			prototype=Screen->LoadEWeaponByUID(id);

			// Didn't find it? Print an error, remove the weapon, and return
			unless(prototype->isValid())
			{
				int error[]="GHost.zh: Failed to find prototype eweapon";
				TraceS(error);
				TraceNL();
				this->DeadState=0;
				return;
			}

			angle=args[GWI_DUMMYANGLE];
			numShots=args[GWI_DUMMYSHOTS];
			spreadType=args[GWI_DUMMYTYPE];

			if(this->Extend==3)
			{
				centerX=this->X+8*this->TileWidth;
				centerY=this->Y+8*this->TileHeight;
			}
			else
			{
				centerX=this->X+8;
				centerY=this->Y+8;
			}

			// Got the data; create some weapons

			// Evenly spaced
			if(spreadType==EWD_EVEN)
			{
				for(float i=0; i<numShots; ++i)
					CopyEWeapon(prototype, centerX, centerY, angle+6.2832*i/numShots);
				Game->PlaySound(prototype->Misc[GWD_SFX]);
			}

			// Random angles
			else if(spreadType==EWD_RANDOM)
			{
				for(int i=0; i<numShots; ++i)
					CopyEWeapon(prototype, centerX, centerY, Rand(31416)/5000);
				Game->PlaySound(prototype->Misc[GWD_SFX]);
			}

			// Aimed at Link
			else // EWD_AIMED
			{
				if(numShots>1)
				{
					float startAngle=ArcTan(Link->X+8-centerX, Link->Y+8-centerY)-angle/2;
					for(int i=0; i<numShots; ++i)
						CopyEWeapon(prototype, centerX, centerY, startAngle+angle*i/(numShots-1));
				}
				else if(numShots==1)
					CopyEWeapon(prototype, centerX, centerY, ArcTan(Link->X+8-centerX, Link->Y+8-centerY));

				Game->PlaySound(prototype->Misc[GWD_SFX]);
			}

			this->DeadState=0;

		}

		void DoEWeaponDeathAimAtLink(eweapon this, int args)
		{
			this->Step=0;
			args[GWI_DEATHARG]-=1;
			if(args[GWI_DEATHARG]<=0)
			{
				this->Angle=RadianAngle(this->X, this->Y, Link->X, Link->Y);
				SetEWeaponDir(this);
				this->Step=300;
				args[GWI_DEATHTYPE]=0;
			}
			
			// Spin while waiting
			else if(this->Angular)
			{
				this->Angle+=0.3;
				SetEWeaponDir(this);
			}
			else
			{
				// Pick a direction based on the counter
				int dir=args[GWI_DEATHARG]&110b;
				if(dir==110b)
					SetEWeaponRotation(this, DIR_UP);
				else if(dir==100b)
					SetEWeaponRotation(this, DIR_RIGHT);
				else if(dir==010b)
					SetEWeaponRotation(this, DIR_DOWN);
				else
					SetEWeaponRotation(this, DIR_LEFT);
			}
		}

		// Some of these could probably be combined...
		void DoEWeaponDeathExplode(eweapon this, int args)
		{
			eweapon bomb = FireNonAngularEWeapon(EW_BOMBBLAST, CenterX(this)-8, CenterY(this)-8, this->Dir, 0, args[GWI_DEATHARG], -1, 0, 0);
			this->DeadState=0;
		}

		void DoEWeaponDeathSBombExplode(eweapon this, int args)
		{
			FireNonAngularEWeapon(EW_SBOMBBLAST, CenterX(this)-8, CenterY(this)-8, this->Dir, 0, args[GWI_DEATHARG], -1, 0, 0);
			this->DeadState=0;
		}

		void DoEWeaponDeath4FireballsHV(eweapon this, int args)
		{
			for(int i=0; i<4; ++i)
			{
				eweapon e = FireNonAngularEWeapon(EW_FIREBALL, CenterX(this)-8, CenterY(this)-8, i, 200, this->Damage/2, args[GWI_DEATHARG], 0, 0);
				if (this->Scale != 1 && this->Scale != 0)
				{
					e->DrawXOffset = this->HitXOffset;
					e->DrawYOffset = this->HitYOffset;
					e->HitXOffset  = this->HitXOffset;
					e->HitYOffset  = this->HitYOffset;
					e->HitWidth    = this->HitWidth;
					e->HitHeight   = this->HitHeight;
					e->Scale = this->Scale;
				}
			}
			args[GWI_FLAGS] = set_bit(args[GWI_FLAGS],EWFI_DEATH_EFFECT_DONE);
			this->DeadState=0;
		}

		void DoEWeaponDeath4FireballsDiag(eweapon this, int args)
		{
			for(int i=4; i<8; ++i)
			{
				eweapon e = FireNonAngularEWeapon(EW_FIREBALL, CenterX(this)-8, CenterY(this)-8, i, 200, this->Damage/2, args[GWI_DEATHARG], 0, 0);
				if (this->Scale != 1 && this->Scale != 0)
				{
					e->DrawXOffset = this->HitXOffset;
					e->DrawYOffset = this->HitYOffset;
					e->HitXOffset  = this->HitXOffset;
					e->HitYOffset  = this->HitYOffset;
					e->HitWidth    = this->HitWidth;
					e->HitHeight   = this->HitHeight;
					e->Scale       = this->Scale;
				}
			}
			args[GWI_FLAGS] = set_bit(args[GWI_FLAGS],EWFI_DEATH_EFFECT_DONE);
			this->DeadState=0;
		}

		void DoEWeaponDeath4FireballsRand(eweapon this, int args)
		{
			if(Rand(2)==0)
			{
				for(int i=0; i<4; ++i)
				{
					eweapon e = FireNonAngularEWeapon(EW_FIREBALL, CenterX(this)-8, CenterY(this)-8, i, 200, this->Damage/2, args[GWI_DEATHARG], 0, 0);
					if (this->Scale != 1 && this->Scale != 0)
					{
						e->DrawXOffset = this->HitXOffset;
						e->DrawYOffset = this->HitYOffset;
						e->HitXOffset  = this->HitXOffset;
						e->HitYOffset  = this->HitYOffset;
						e->HitWidth    = this->HitWidth;
						e->HitHeight   = this->HitHeight;
						e->Scale = this->Scale;
					}
				}
			}
			else
			{
				for(int i=4; i<8; ++i)
				{
					eweapon e = FireNonAngularEWeapon(EW_FIREBALL, CenterX(this)-8, CenterY(this)-8, i, 200, this->Damage/2, args[GWI_DEATHARG], 0, 0);
					if (this->Scale != 1 && this->Scale != 0)
					{
						e->DrawXOffset = this->HitXOffset;
						e->DrawYOffset = this->HitYOffset;
						e->HitXOffset  = this->HitXOffset;
						e->HitYOffset  = this->HitYOffset;
						e->HitWidth    = this->HitWidth;
						e->HitHeight   = this->HitHeight;
						e->Scale = this->Scale;
					}
				}
			}
			args[GWI_FLAGS] = set_bit(args[GWI_FLAGS],EWFI_DEATH_EFFECT_DONE);
			this->DeadState=0;
		}

		void DoEWeaponDeath8Fireballs(eweapon this, int args)
		{
			for(int i=0; i<8; ++i)
			{
				eweapon e = FireNonAngularEWeapon(EW_FIREBALL, CenterX(this)-8, CenterY(this)-8, i, 200, this->Damage/2, args[GWI_DEATHARG], 0, 0);
				if (this->Scale != 1 && this->Scale != 0)
				{
					e->DrawXOffset = this->HitXOffset;
					e->DrawYOffset = this->HitYOffset;
					e->HitXOffset  = this->HitXOffset;
					e->HitYOffset  = this->HitYOffset;
					e->HitWidth    = this->HitWidth;
					e->HitHeight   = this->HitHeight;
					e->Scale = this->Scale;
				}
			}
			args[GWI_FLAGS] = set_bit(args[GWI_FLAGS],EWFI_DEATH_EFFECT_DONE);
			this->DeadState=0;
		}

		void DoEWeaponDeath4FiresHV(eweapon this, int args)
		{
			for(int i=0; i<4; ++i)
				FireNonAngularEWeapon(EW_FIRE, CenterX(this)-8, CenterY(this)-8, i, 100, this->Damage/2, args[GWI_DEATHARG], 0, 0);
			Game->PlaySound(SFX_FIRE); // Only play sound once
			args[GWI_FLAGS] = set_bit(args[GWI_FLAGS],EWFI_DEATH_EFFECT_DONE);
			this->DeadState=0;
		}

		void DoEWeaponDeath4FiresDiag(eweapon this, int args)
		{
			for(int i=4; i<8; ++i)
				FireNonAngularEWeapon(EW_FIRE, CenterX(this)-8, CenterY(this)-8, i, 71, this->Damage/2, args[GWI_DEATHARG], 0, 0);
			Game->PlaySound(SFX_FIRE);
			args[GWI_FLAGS] = set_bit(args[GWI_FLAGS],EWFI_DEATH_EFFECT_DONE);
			this->DeadState=0;
		}

		void DoEWeaponDeath4FiresRand(eweapon this, int args)
		{
			if(Rand(2)==0)
			{
				for(int i=0; i<4; ++i)
					FireNonAngularEWeapon(EW_FIRE, CenterX(this)-8, CenterY(this)-8, i, 100, this->Damage/2, args[GWI_DEATHARG], 0, 0);
			}
			else
			{
				for(int i=4; i<8; ++i)
					FireNonAngularEWeapon(EW_FIRE, CenterX(this)-8, CenterY(this)-8, i, 71, this->Damage/2, args[GWI_DEATHARG], 0, 0);
			}

			Game->PlaySound(SFX_FIRE);
			args[GWI_FLAGS] = set_bit(args[GWI_FLAGS],EWFI_DEATH_EFFECT_DONE);
			this->DeadState=0;
		}

		void DoEWeaponDeath8Fires(eweapon this, int args)
		{
			for(int i=0; i<4; ++i)
				FireNonAngularEWeapon(EW_FIRE, CenterX(this)-8, CenterY(this)-8, i, 100, this->Damage/2, args[GWI_DEATHARG], 0, 0);
			for(int i=4; i<8; ++i)
				FireNonAngularEWeapon(EW_FIRE, CenterX(this)-8, CenterY(this)-8, i, 71, this->Damage/2, args[GWI_DEATHARG], 0, 0);
			Game->PlaySound(SFX_FIRE);
			args[GWI_FLAGS] = set_bit(args[GWI_FLAGS],EWFI_DEATH_EFFECT_DONE);
			this->DeadState=0;
		}

		void DoEWeaponDeathSingleFire(eweapon this, int args)
		{
			FireNonAngularEWeapon(EW_FIRE, CenterX(this)-8, CenterY(this)-8, this->Dir, 0, this->Damage/2, args[GWI_DEATHARG], 0, 0);
			Game->PlaySound(SFX_FIRE);
			args[GWI_FLAGS] = set_bit(args[GWI_FLAGS],EWFI_DEATH_EFFECT_DONE);
			this->DeadState=0;
		}

		void DoEWeaponDeathSpawnNPC(eweapon this, int args)
		{
			npc enemy=Screen->CreateNPC(args[GWI_DEATHARG]);
			enemy->X=this->X;
			enemy->Y=this->Y;
			args[GWI_FLAGS] = set_bit(args[GWI_FLAGS],EWFI_DEATH_EFFECT_DONE);
			this->DeadState=0;
		}

		void DoEWeaponDeathRunScriptFFC(eweapon this, int args)
		{
			int ffcID;
			ffc f;
			
			// First, find a free FFC
			ffcID=FindUnusedFFC();
			unless(ffcID)
			{
				// None available; just remove the weapon
				this->DeadState=0;
				return;
			}
			f=Screen->LoadFFC(ffcID);
			
			// Set the death effect done flag so this doesn't repeat every frame
			args[GWI_FLAGS] = set_bit(args[GWI_FLAGS],EWFI_DEATH_EFFECT_DONE);
			
			// Then run the script
			f->Data=Game->Ghost[GHV_SETTINGS_COMBO_ID];
			f->X=CenterX(this)-8;
			f->Y=CenterY(this)-8;
			f->Flags[FFCF_ETHEREAL] = (Game->Ghost[GHV_LEG_ETHEREAL]) ? true : false;
			if (Game->Ghost[GHV_CLEAR_FFC_LINK_DEP]) f->Link = 0;
			f->Script=args[GWI_DEATHARG];
			f->InitD[0]=this->UID;
		}
		void DoEWeaponDeathRunScriptLWeapon(eweapon this, int args)
		{
			// Set the death effect done flag so this doesn't repeat every frame
			args[GWI_FLAGS] = set_bit(args[GWI_FLAGS],EWFI_DEATH_EFFECT_DONE);
			
			lweapon f = Screen->CreateLWeapon(LW_GHOSTDEATH);
			f->Script=args[GWI_DEATHARG];
			f->InitD[0]=this->UID;
		}
		void DoEWeaponDeathRunScriptEWeapon(eweapon this, int args)
		{
			// Set the death effect done flag so this doesn't repeat every frame
			args[GWI_FLAGS] = set_bit(args[GWI_FLAGS],EWFI_DEATH_EFFECT_DONE);
			
			eweapon f = Screen->CreateEWeapon(EW_GHOSTDEATH);
			f->Script=args[GWI_DEATHARG];
			f->InitD[0]=this->UID;
		}
		void DoEWeaponParticles(eweapon this, int args)
		{
			int id;
			eweapon prototype;
			int centerX;
			int centerY;
			
			// Find the prototype
			id=args[GWI_PARTICLEWPN];
			unless(id == 0)
			{
				prototype=Screen->LoadEWeaponByUID(id);

				// Didn't find it? Print an error, remove the weapon, and return
				unless(prototype->isValid())
				{
					int error[]="GHost.zh: Failed to find prototype eweapon";
					TraceS(error);
					TraceNL();
					this->DeadState=0;
					return;
				}
				
				++args[GWI_PARTICLETIMER];
				unless ((args[GWI_PARTICLETIMER] % prototype->Misc[GWD_FREQ]))
				{
				
					if(this->Extend==3)
					{
						centerX=this->X+8*this->TileWidth;
						centerY=this->Y+8*this->TileHeight;
					}
					else
					{
						centerX=this->X+8;
						centerY=this->Y+8;
					}
					
					centerX += Rand(args[GWI_PARTICLEOFFSET], -args[GWI_PARTICLEOFFSET]);
					centerY += Rand(args[GWI_PARTICLEOFFSET], -args[GWI_PARTICLEOFFSET]);

					CopyEWeapon(prototype, centerX, centerY, this->Angle, this->Z);
					Game->PlaySound(prototype->Misc[GWD_SFX]);
				}
			}
		}
	}



	// Fire an eweapon
	eweapon FireEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, long flags)
	{
		if(sprite<0)
			sprite=GetDefaultEWeaponSprite(weaponID);
		
		if(sound<0)
			sound=GetDefaultEWeaponSound(weaponID);
		
		eweapon wpn=Screen->CreateEWeapon(weaponID);
		wpn->X=x;
		wpn->Y=y;
		wpn->Step=step;
		wpn->Damage=damage;
		wpn->Angular=true;
		wpn->Angle=angle;
		
		if(sprite>=0)
			wpn->UseSprite(sprite);
		
		wpn->Script = Game->GetEWeaponScript("GhostWeapon");
		wpn->InitD[7]=flags;
		
		SetEWeaponDir(wpn); // After flags so unblockability is detected
		
		if((flags&EWF_NO_COLLISION)!=0)
			wpn->CollDetection=false;
		
		if((flags&EWF_ROTATE)!=0)
			SetEWeaponRotation(wpn);
		
		Game->PlaySound(sound);
		
		return wpn;
	}


	// Fire an eweapon aimed based on Link's position
	eweapon FireAimedEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, long flags)
	{
		return FireEWeapon(weaponID, x, y, ArcTan(Link->X-x, Link->Y-y)+angle, step, damage, sprite, sound, flags);
	}


	// Fire a non-angular eweapon
	eweapon FireNonAngularEWeapon(int weaponID, int x, int y, int dir, int step, int damage, int sprite, int sound, long flags)
	{
		if(sprite<0)
			sprite=GetDefaultEWeaponSprite(weaponID);
		
		if(sound<0)
			sound=GetDefaultEWeaponSound(weaponID);
		
		eweapon wpn=Screen->CreateEWeapon(weaponID);
		wpn->X=x;
		wpn->Y=y;
		wpn->Step=step;
		wpn->Damage=damage;
		wpn->Angular=false;
		
		if((flags&EWF_UNBLOCKABLE))
			wpn->Dir=UnblockableDir(dir);
		else
			wpn->Dir=dir;
			
		if(sprite>=0)
			wpn->UseSprite(sprite);

		if((flags&EWF_NO_COLLISION)!=0)
			wpn->CollDetection=false;

		if((flags&EWF_ROTATE))
			SetEWeaponRotation(wpn);
		
		wpn->Script = Game->GetEWeaponScript("GhostWeapon");
		wpn->InitD[7]=flags;
		
		Game->PlaySound(sound);
		return wpn;
	}


	// Fire an eweapon larger than 1x1
	eweapon FireBigEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, long flags, int width, int height)
	{
		eweapon wpn=FireEWeapon(weaponID, x, y, angle, step, damage, sprite, sound, flags);
		wpn->Extend=3;
		wpn->TileWidth=width;
		wpn->TileHeight=height;
		wpn->HitWidth=16*width;
		wpn->HitHeight=16*height;
		return wpn;
	}


	// Fire an eweapon larger than 1x1 aimed based on Link's position
	eweapon FireBigAimedEWeapon(int weaponID, int x, int y, float angle, int step, int damage, int sprite, int sound, long flags, int width, int height)
	{
		eweapon wpn=FireEWeapon(weaponID, x, y, ArcTan(Link->X-x, Link->Y-y)+angle, step, damage, sprite, sound, flags);
		wpn->Extend=3;
		wpn->TileWidth=width;
		wpn->TileHeight=height;
		wpn->HitWidth=16*width;
		wpn->HitHeight=16*height;
		return wpn;
	}


	// Fire a non-angular eweapon larger than 1x1
	eweapon FireBigNonAngularEWeapon(int weaponID, int x, int y, int dir, int step, int damage, int sprite, int sound, long flags, int width, int height)
	{
		eweapon wpn=FireNonAngularEWeapon(weaponID, x, y, dir, step, damage, sprite, sound, flags);
		wpn->Extend=3;
		wpn->TileWidth=width;
		wpn->TileHeight=height;
		wpn->HitWidth=16*width;
		wpn->HitHeight=16*height;
		return wpn;
	}

	// Create a dummy eweapon to use as a prototype
	eweapon CreateDummyEWeapon(int weaponID, int step, int damage, int sprite, int sound, long flags)
	{
		eweapon wpn=Screen->CreateEWeapon(weaponID);
		eweapon checkWpn;
		int minID;
		wpn->Step=0;
		wpn->Damage=damage;
		wpn->Script = Game->GetEWeaponScript("DummyWeapon");
		wpn->Misc[GWD_STEP]=step;
		wpn->Misc[GWD_SFX]=sound;
		wpn->Misc[GWD_SPRITE]=sprite;
		
		wpn->InitD[7]=flags;
		
		wpn->CollDetection=false;
		wpn->DrawXOffset=32768;
		
		// Move it to make sure it's not deleted
		wpn->X=32;
		wpn->Y=32;
		
		return wpn;
	}


	// Create a dummy eweapon larger than 1x1
	eweapon CreateBigDummyEWeapon(int weaponID, int step, int damage, int sprite, int sound, long flags, int width, int height)
	{
		eweapon wpn=CreateDummyEWeapon(weaponID, step, damage, sprite, sound, flags);
		wpn->Extend=3;

		wpn->TileWidth=width;
		wpn->TileHeight=height;
		// No point setting the hitbox here
		return wpn;
	}


	// Set an eweapon's movement type
	void SetEWeaponMovement(eweapon wpn, int type, int arg, int arg2)
	{
		unless (wpn->Script == Game->GetEWeaponScript("DummyWeapon") || wpn->Script == Game->GetEWeaponScript("GhostWeapon")) wpn->Script = Game->GetEWeaponScript("GhostWeapon");
		unless(wpn->Misc[GWM_SETTINGS])
		{
			//wpn->Misc[__EWI_WORK]=0;
			wpn->InitD[0]=type;
			wpn->InitD[1]=arg;
			wpn->InitD[2]=arg2;

			
			if(type==EWM_THROW)
			{
				// Necessary upward velocity to reach Link for thrown weapons
				if(arg<=0)
				{
					// Special case for dummy weapons
					if(wpn->Script == Game->GetEWeaponScript("DummyWeapon"))
						wpn->InitD[1]=-1;

					else
						wpn->InitD[1]=GetEWeaponThrowheight(wpn);
				}
			}
			else if(type==EWM_FALL)
				wpn->Z=arg;
		}
		else
		{
			int args = wpn->Misc[GWM_SETTINGS];
			// Dummies normally use __EWI_XPOS and __EWI_YPOS for other purposes,
			// so don't overwrite them
			if (wpn->Script == Game->GetEWeaponScript("GhostWeapon"))
			{
				args[GWI_TRUEX]=wpn->X;
				args[GWI_TRUEY]=wpn->Y;
			}
			args[GWI_MOVEMENT]=type;
			args[GWI_MOVEARG1]=arg;
			args[GWI_MOVEARG2]=arg2;

			if(type==EWM_HOMING_REAIM || type==EWM_RANDOM_REAIM)
			{
				// Dummy? Use its stored step instead of its real step
				if(wpn->Script == Game->GetEWeaponScript("DummyWeapon"))
					args[GWI_MISC2]=wpn->Misc[GWD_STEP];
				else
					args[GWI_MISC2]=wpn->Step;
			}
			else if(type==EWM_THROW)
			{
				args[GWI_MISC2]=wpn->Z;

				// Necessary upward velocity to reach Link for thrown weapons
				if(arg<=0)
				{
					// Special case for dummy weapons
					if(wpn->Script == Game->GetEWeaponScript("DummyWeapon"))
						args[GWI_MOVEARG1]=-1;

					else
						args[GWI_MOVEARG1]=GetEWeaponThrowheight(wpn);
				}
			}
			else if(type==EWM_FALL)
			{
				wpn->Z=arg;
				args[GWI_MISC2]=arg;
				args[GWI_MISC1]=Game->Gravity[GR_STRENGTH];
			}
		}
	}

	// Returns the Z velocity at which a weapon should be thrown
	// to land at Link's position.
	float GetEWeaponThrowheight(eweapon wpn)
	{
		float step=wpn->Step/100;
		if(step<=0)
			return 1;
		
		float dist=Distance(wpn->X+wpn->HitWidth/2, wpn->Y+wpn->HitHeight/2,
		  Link->X+8, Link->Y+8);
		if(dist<1)
			return 1;
		
		float travelTime=dist/step;
		float ret=0;
		
		// Every increase in velocity of the gravity value means two frames in the air.
		// This might overshoot by a frame, but that's all right.
		while(ret<=Game->Gravity[GR_TERMINALV])
		{
			ret += Game->Gravity[GR_STRENGTH];
			travelTime-=2;
			if(travelTime<=0)
				return ret;
		}
		
		// Needs to exceed terminal velocity. Slightly trickier here, because
		// an increase of the gravity value may mean more than two more frames in the air.
		float excess=0; // Distance left to fall after reaching TV
		while(travelTime>excess/Game->Gravity[GR_TERMINALV])
		{
			ret += Game->Gravity[GR_STRENGTH];
			excess+=ret-Game->Gravity[GR_TERMINALV];
			travelTime-=2;
		}
		
		return ret;
	}

	// Set an eweapon's lifespan
	void SetEWeaponLifespan(eweapon wpn, int type, int arg)
	{
		unless (wpn->Script == Game->GetEWeaponScript("DummyWeapon") || wpn->Script == Game->GetEWeaponScript("GhostWeapon")) wpn->Script = Game->GetEWeaponScript("GhostWeapon");
		unless(wpn->Misc[GWM_SETTINGS])
		{
			wpn->InitD[3]=type;
			wpn->InitD[4]=arg;
			if (type == EWL_GROW) SetExInit(wpn, GWMI_INITLIFEMISC, 0.02);
			if (type == EWL_SHRINK) SetExInit(wpn, GWMI_INITLIFEMISC, -0.02);
		}
		else
		{
			int args = wpn->Misc[GWM_SETTINGS];
			args[GWI_LIFESPAN]=type;
			args[GWI_LIFEARG]=arg;
			if (type == EWL_GROW) args[GWI_LIFEMISC] = 0.02;
			if (type == EWL_SHRINK) args[GWI_LIFEMISC] = -0.02;
		}
	}


	// Set an eweapon to use a standard death effect
	void SetEWeaponDeathEffect(eweapon wpn, int type, int arg)
	{
		unless (wpn->Script == Game->GetEWeaponScript("DummyWeapon") || wpn->Script == Game->GetEWeaponScript("GhostWeapon")) wpn->Script = Game->GetEWeaponScript("GhostWeapon");
		// Make sure the script number is valid
		switch(type)
		{
			case EWD_RUN_SCRIPT:
			case EWD_RUN_SCRIPTLW:
			case EWD_RUN_SCRIPTEW:
			{
				if(arg<1 || arg>511)
				type=EWD_VANISH;
				break;
			}
			
			
		}
		
		unless(wpn->Misc[GWM_SETTINGS])
		{
			wpn->InitD[5]=type;
			wpn->InitD[6]=arg;
		}
		else
		{
			int args = wpn->Misc[GWM_SETTINGS];
			args[GWI_DEATHTYPE]=type;
			args[GWI_DEATHARG]=arg;
		}
	}


	// Set an eweapon to spawn more eweapons on death
	void SetEWeaponDeathEffect(eweapon wpn, eweapon prototype, int numShots, int spreadType, float angle)
	{
		unless (wpn->Script == Game->GetEWeaponScript("DummyWeapon") || wpn->Script == Game->GetEWeaponScript("GhostWeapon"))
		{
			wpn->Script = Game->GetEWeaponScript("GhostWeapon");
		}
		unless(wpn->Misc[GWM_SETTINGS])
		{
			SetExInit(wpn, GWMI_PROTOTYPEUID, prototype->UID);
			SetExInit(wpn, GWMI_PROTOTYPESHOTS, numShots);
			SetExInit(wpn, GWMI_PROTOTYPEMISC, spreadType*100+(WrapAngle(angle)+6.2832));
		}
		else
		{
			int args = wpn->Misc[GWM_SETTINGS];
			args[GWI_DUMMYWPN] = prototype->UID;
			args[GWI_DUMMYTYPE]= spreadType;
			args[GWI_DUMMYSHOTS]= numShots;
			args[GWI_DUMMYANGLE]= angle;
		}
	}

	// Used when Link is holding up an item. UpdateEWeapon() doesn't run, but
	// the appearance-related flags still need handled.
	void UpdateEWeaponVisualFlags(eweapon wpn)
	{
		int args = wpn->Misc[GWM_SETTINGS];
		unless(args) return;
		
		if(args[GWI_FLAGS] & EWF_ROTATE_360)
		{
			wpn->DrawXOffset=1000;
			
			// Flickering? Nothing to do here.
			if((args[GWI_FLAGS] & EWF_FLICKER) && (Game->Time & 10bL))
				return;
			
			// This works a little differently than in UpdateEWeapon(). Since
			// movement isn't updating normally, the angle or direction are
			// always used. It's not perfect, but it'll have to do.
			
			float angle;
			
			if(wpn->Angular)
			{
				angle=RadtoDeg(wpn->Angle);
			}
			else
			{
				int dir=NormalizeDir(wpn->Dir);
				switch(dir)
				{
					case DIR_UP:
						angle=-90; break;
					case DIR_RIGHTUP:
						angle=-45; break;
					case DIR_RIGHT:
						angle=0; break;
					case DIR_RIGHTDOWN:
						angle=45; break;
					case DIR_DOWN:
						angle=90; break;
					case DIR_LEFTDOWN: 
						angle=135; break;
					case DIR_LEFT:
						angle=180; break;
					case DIR_LEFTUP:
						angle=-135; break;
					default: printf("Invalid dir (%d) supplied to ghost3::UpdateEWeaponVisualFlags\n", dir); break;
				}
			}
			
			int flip;
			switch(angle)
			{
				case 0...179:
					flip = 0;
					break;
				default: 
					flip = 2;
					break;
			}
			
			// Currently, these are always drawn on layer 4.
			// That should probably be changed...
			Screen->DrawTile(4, wpn->X, wpn->Y-wpn->Z, wpn->Tile, 1, 1, wpn->CSet,
							 -1, -1, wpn->X, wpn->Y-wpn->Z, angle, flip, true, OP_OPAQUE);
		}
		else // EWF_ROTATE_360 isn't set
		{
			if(args[GWI_FLAGS] & EWF_FLICKER)
			{
				// Weapons can't be made invisible; use DrawXOffset instead
				if(Game->Time & 10bL)
					wpn->DrawXOffset=1000;
				else
					wpn->DrawXOffset=0;
			}
			
			if(args[GWI_FLAGS] & EWF_ROTATE)
				SetEWeaponRotation(wpn);
		}
	}

	// Set the weapon's direction based on its angle;
	// Can also makes weapons unblockable
	void SetEWeaponDir(eweapon wpn)
	{
		float angle=wpn->Angle%6.2832;
		int dir;
		
		if(angle<0)
			angle+=6.2832;
		
		if(angle<0.3927 || angle>5.8905)
			dir=DIR_RIGHT;
		else if(angle<1.1781)
			dir=DIR_RIGHTDOWN;
		else if(angle<1.9635)
			dir=DIR_DOWN;
		else if(angle<2.7489)
			dir=DIR_LEFTDOWN;
		else if(angle<3.5343)
			dir=DIR_LEFT;
		else if(angle<4.3197)
			dir=DIR_LEFTUP;
		else if(angle<5.1051)
			dir=DIR_UP;
		else
			dir=DIR_RIGHTUP;
		
		int args = wpn->Misc[GWM_SETTINGS];
		unless(args) return;
		
		if(args[GWI_FLAGS] & EWF_UNBLOCKABLE)
			dir=UnblockableDir(dir);
		
		wpn->Dir=dir;
	}


	// Flip the weapon's sprite to match its direction
	void SetEWeaponRotation(eweapon wpn)
	{
		if(wpn->Angular)
		{
			float angle=wpn->Angle%6.2832;
			if(angle<0)
				angle+=6.2832;

			if(angle<0.7854 || angle>5.4978) // Right
				wpn->Flip=4;
			else if(angle<=2.3562) // Down
				wpn->Flip=3;
			else if(angle<3.927) // Left
				wpn->Flip=7;
			else // Up
				wpn->Flip=0;
		}
		else
		{
			int dir=NormalizeDir(wpn->Dir);
			if(dir==DIR_UP || dir==DIR_RIGHTUP || dir==DIR_LEFTUP)
				wpn->Flip=0;
			else if(dir==DIR_DOWN || dir==DIR_RIGHTDOWN || dir==DIR_LEFTDOWN)
				wpn->Flip=3;
			else if(dir==DIR_LEFT)
				wpn->Flip=7;
			else // Right
				wpn->Flip=4;
		}
	}


	// Flip the weapon's sprite to match the given direction
	void SetEWeaponRotation(eweapon wpn, int dir)
	{
		dir=NormalizeDir(dir);
		switch(dir)
		{
			
			case DIR_UP:
			case DIR_RIGHTUP:
			case DIR_LEFTUP:
				wpn->Flip=0; break;
			case DIR_DOWN:
			case DIR_RIGHTDOWN:
			case DIR_LEFTDOWN:
				wpn->Flip=3; break;
			case DIR_LEFT:
				wpn->Flip=7; break;
			case DIR_RIGHT:
				wpn->Flip=4; break;
			default: printf("Invalid dir (%d) passed to SetEWeaponRotation().\n", dir); break;
		}
	}


	// Kill an eweapon, triggering any death effects
	void KillEWeapon(eweapon wpn)
	{
		int args = wpn->Misc[GWM_SETTINGS];
		unless(args) return;
		args[GWI_FLAGS] = set_bit(args[GWI_FLAGS],EWFI_DEAD);
	}


	// Get the standard sprite for this weapon type
	int GetDefaultEWeaponSprite(int weaponID)
	{
		switch(weaponID)
		{
			case EW_FIREBALL:
			case EW_FIREBALL2:
				return SP_FIREBALL;
			case EW_ROCK:	
				return SP_ROCK;
			case EW_ARROW:
				return SP_ARROW_ENEMY;
			case EW_FIRE:
				return SP_FIRE_ENEMY;
			case EW_FIRE2:
				return SP_FIRE2_ENEMY;
			case EW_FIRETRAIL:
				return SP_FIRETRAIL;
			case EW_MAGIC:
				return SP_MAGIC_ENEMY;
			case EW_BEAM:
				return SP_SWORD_ENEMY;
			case EW_WIND:
				return SP_WIND;
			case EW_BOMB:
				return SP_BOMB_ENEMY;
			case EW_SBOMB:
				return SP_SBOMB_ENEMY;;
			case EW_BRANG:
			{
				// The sprite depends on what boomerang Link has, so check his inventory
				int maxLevel=0;
				itemdata id;

				for(int i=0; i<256; i++)
				{
					if(!Link->Item[i])
						continue;

					id=Game->LoadItemData(i);

					if(id->Family!=IC_BRANG)
						continue;

					if(id->Level>maxLevel)
					{
						maxLevel=id->Level;
						if(maxLevel>=3) // Any higer won't matter
							break;
					}

				}

				if(maxLevel<=1)
					return SP_BRANG1;
				else if(maxLevel==2)
					return SP_BRANG2;
				else
					return SP_BRANG3;
			}
			default: return NULL;
		}
	}


	// Find the sound normally made by weapons of this type
	int GetDefaultEWeaponSound(int weaponID)
	{
		switch(weaponID)
		{
			case EW_FIREBALL:
			case EW_FIREBALL2:
				return SFX_FIREBALL;
			case EW_MAGIC:
			case EW_WIND:
				return SFX_WAND;
			case EW_FIRE:
			case EW_FIRE2:
			case EW_FIRETRAIL:
				return SFX_FIRE;
			case EW_ROCK:
				return SFX_ROCK;
			default:
				return NULL;
		}
	}


	// Use this in a script started on eweapon death to find the weapon
	// that created it
	eweapon GetAssociatedEWeapon(int weaponID)
	{
		eweapon wpn = Screen->LoadEWeaponByUID(weaponID);
		return wpn;
	}

	//! This should be a bitwise flag of the weapon's Misc on an appropriate index!!! -Z
	// Is this a GHost.zh-controlled weapon?
	bool IsGHostZHEWeapon(eweapon wpn)
	{
		return (wpn->Script == Game->GetEWeaponScript("GhostWeapon"));
	}

	//! This should be a bitwise flag of the weapon's Misc on an appropriate index!!! -Z
	// Is this a dummy weapon?
	bool IsDummyEWeapon(eweapon wpn)
	{
		return (wpn->Script == Game->GetEWeaponScript("DummyWeapon"));
	}


	// Make a copy of the given eweapon, which should be a dummy
	void CopyEWeapon(eweapon prototype, int centerX, int centerY, float angle, int centerZ)
	{
		eweapon wpn=Screen->CreateEWeapon(prototype->ID);
		if(prototype->Misc[GWD_SPRITE]>0)
			wpn->UseSprite(prototype->Misc[GWD_SPRITE]);

		if(prototype->Extend==3)
		{
			wpn->Extend=3;
			wpn->TileWidth=prototype->TileWidth;
			wpn->TileHeight=prototype->TileHeight;
			wpn->HitWidth=16*prototype->TileWidth;
			wpn->HitHeight=16*prototype->TileHeight;
			wpn->X=centerX-8*wpn->TileWidth;
			wpn->Y=centerY-8*wpn->TileWidth;
		}
		else
		{
			wpn->X=centerX-8;
			wpn->Y=centerY-8;
		}
		
		wpn->Z = centerZ;

		wpn->Behind = prototype->Behind;
		wpn->Step=prototype->Misc[GWD_STEP];
		wpn->Damage=prototype->Damage;
		wpn->Angular=true;
		wpn->Angle=angle;
		SetEWeaponDir(wpn);
		
		int args = prototype->Misc[GWM_SETTINGS];
		
		unless(args) return;
		
		wpn->Script = Game->GetEWeaponScript("GhostWeapon");
		
		wpn->InitD[0]=args[GWI_MOVEMENT];
		wpn->InitD[2]=args[GWI_MOVEARG2];

		// Special case for thrown weapons with automatic velocity
		if(args[GWI_MOVEMENT]==EWM_THROW && args[GWI_MOVEARG1]==-1)
			wpn->InitD[1]=GetEWeaponThrowheight(wpn);
		else
			wpn->InitD[1]=args[GWI_MOVEARG1];

		wpn->InitD[3]=args[GWI_LIFESPAN];
		wpn->InitD[4]=args[GWI_LIFEARG];
		wpn->InitD[5]=args[GWI_DEATHTYPE];
		wpn->InitD[6]=args[GWI_DEATHARG];
		wpn->InitD[7]=args[GWI_FLAGS];

		if(args[GWI_FLAGS] & EWF_NO_COLLISION)
			wpn->CollDetection=false;

		if(args[GWI_FLAGS] & EWF_ROTATE)
			SetEWeaponRotation(wpn);
	}
	
	void CopyEWeapon(eweapon prototype, int centerX, int centerY, float angle)
	{
		eweapon wpn=Screen->CreateEWeapon(prototype->ID);
		if(prototype->Misc[GWD_SPRITE]>0)
			wpn->UseSprite(prototype->Misc[GWD_SPRITE]);

		if(prototype->Extend==3)
		{
			wpn->Extend=3;
			wpn->TileWidth=prototype->TileWidth;
			wpn->TileHeight=prototype->TileHeight;
			wpn->HitWidth=16*prototype->TileWidth;
			wpn->HitHeight=16*prototype->TileHeight;
			wpn->X=centerX-8*wpn->TileWidth;
			wpn->Y=centerY-8*wpn->TileWidth;
		}
		else
		{
			wpn->X=centerX-8;
			wpn->Y=centerY-8;
		}

		wpn->Behind = prototype->Behind;
		wpn->Step=prototype->Misc[GWD_STEP];
		wpn->Damage=prototype->Damage;
		wpn->Angular=true;
		wpn->Angle=angle;
		SetEWeaponDir(wpn);
		
		int args = prototype->Misc[GWM_SETTINGS];
		
		unless(args) return;
		
		wpn->Script = Game->GetEWeaponScript("GhostWeapon");
		
		wpn->InitD[0]=args[GWI_MOVEMENT];
		wpn->InitD[2]=args[GWI_MOVEARG2];

		// Special case for thrown weapons with automatic velocity
		if(args[GWI_MOVEMENT]==EWM_THROW && args[GWI_MOVEARG1]==-1)
			wpn->InitD[1]=GetEWeaponThrowheight(wpn);
		else
			wpn->InitD[1]=args[GWI_MOVEARG1];

		wpn->InitD[3]=args[GWI_LIFESPAN];
		wpn->InitD[4]=args[GWI_LIFEARG];
		wpn->InitD[5]=args[GWI_DEATHTYPE];
		wpn->InitD[6]=args[GWI_DEATHARG];
		wpn->InitD[7]=args[GWI_FLAGS];

		if(args[GWI_FLAGS] & EWF_NO_COLLISION)
			wpn->CollDetection=false;

		if(args[GWI_FLAGS] & EWF_ROTATE)
			SetEWeaponRotation(wpn);
	}


	// Get the unblockable version (8-15) of a direction
	int UnblockableDir(int dir)
	{
		switch(dir)
		{
			case DIR_UP: return 8;
			case DIR_DOWN: return 12;
			case DIR_LEFT: return 14;
			case DIR_RIGHT: return 10;
			case DIR_LEFTUP: return 15;
			case DIR_RIGHTUP: return 9;
			case DIR_LEFTDOWN: return 13;
			case DIR_RIGHTDOWN: return 11;
			default: return dir; // Should never get here
		}
	}
	
	bool IsInitialized(eweapon e)
	{
		return (e->Misc[GWM_SETTINGS] > 0);
	}
	
	int GetSettingsArray(eweapon e)
	{
		if (IsInitialized(e))
			return e->Misc[GWM_SETTINGS];
			
		return -1;
	}
	
	void SetEWeaponSparkleFrequency(eweapon e, int frequency)
	{
		if (IsDummyEWeapon(e))
		{
			e->Misc[GWD_FREQ] = frequency;
			return;
		}
		if (IsGHostZHEWeapon(e))
		{
			if (IsInitialized(e))
			{
				int arr = GetSettingsArray(e);
				int uid = arr[GWI_PARTICLEWPN];
				eweapon particle = Screen->LoadEWeaponByUID(uid);
				particle->Misc[GWD_FREQ] = frequency;
			}
			else
			{
				int uid = GetExInit(e, GWMI_PARTICLEUID);
				eweapon particle = Screen->LoadEWeaponByUID(uid);
				particle->Misc[GWD_FREQ] = frequency;
			}
		}
	}
	void SetEWeaponSparkle(eweapon e, eweapon dummy)
	{
		if (IsGHostZHEWeapon(e) && IsDummyEWeapon(dummy))
		{
			if (IsInitialized(e))
			{
				int arr = GetSettingsArray(e);
				arr[GWI_PARTICLEWPN] = dummy->UID;
			}
			else
			{
				SetExInit(e, GWMI_PARTICLEUID, dummy->UID);
			}
		}
	}
	lweapon CreateDataWeapon(untyped arr)
	{
		lweapon wpn = Screen->CreateLWeapon(LW_SPARKLE);
		wpn->Step=0;
		wpn->Damage = 0;
		
		wpn->CollDetection=false;
		wpn->DrawXOffset=32768;
		wpn->HitXOffset=32768;
		wpn->NumFrames = 2;
		wpn->ASpeed = 1;
		
		// Move it to make sure it's not deleted
		wpn->X=32;
		wpn->Y=32;
		
		int sz = Min(SizeOfArray(arr), 8);
		for(int q = sz-1; q >= 0; --q)
		{
			wpn->InitD[q] = arr[q];
		}
		
		return wpn;
	}
	void SetExInit(eweapon e, GW_EXINIT index, untyped value)
	{
		if (e->Misc[GWM_INITSTUFF])
		{
			lweapon data = Screen->LoadLWeaponByUID(e->Misc[GWM_INITSTUFF]);
			if (data->isValid())
			{
				if (index < 8) data->InitD[index] = value;
			}
			else
			{
				int arr[8];
				if (index < 8) arr[index] = value;
				data = CreateDataWeapon(arr);
				e->Misc[GWM_INITSTUFF] = data->UID;
			}
		}
		else
		{
			int arr[8];
			if (index < 8) arr[index] = value;
			lweapon data = CreateDataWeapon(arr);
			e->Misc[GWM_INITSTUFF] = data->UID;
		}
		if (index >= 8)
		{
			lweapon data = Screen->LoadLWeaponByUID(e->Misc[GWM_INITSTUFF]);
			if (data->isValid()) //If it isn't valid, then attempts to create it last time failed, so don't even bother trying again.
			{
				if (data->Misc[GWM_INITSTUFF])
				{
					lweapon data2 = Screen->LoadLWeaponByUID(data->Misc[GWM_INITSTUFF]);
					if (data2->isValid())
					{
						if (index < 8) data2->InitD[index-8] = value;
					}
					else
					{
						int arr[8];
						if (index < 16) arr[index-8] = value;
						data2 = CreateDataWeapon(arr);
						data->Misc[GWM_INITSTUFF] = data2->UID;
					}
				}
				else
				{
					int arr[8];
					if (index < 16) arr[index-8] = value;
					lweapon data2 = CreateDataWeapon(arr);
					data->Misc[GWM_INITSTUFF] = data2->UID;
				}
			}
		}
	}
	void SetExInits(eweapon e, untyped arr)
	{
		bool full = false;
		if (SizeOfArray(arr) > 8) full = true;
		if (e->Misc[GWM_INITSTUFF])
		{
			lweapon data = Screen->LoadLWeaponByUID(e->Misc[GWM_INITSTUFF]);
			if (data->isValid())
			{
				int sz = Min(SizeOfArray(arr), 8);
				for(int q = sz-1; q >= 0; --q)
				{
					data->InitD[q] = arr[q];
				}
			}
			else
			{
				data = CreateDataWeapon(arr);
				e->Misc[GWM_INITSTUFF] = data->UID;
			}
		}
		else
		{
			lweapon data = CreateDataWeapon(arr);
			e->Misc[GWM_INITSTUFF] = data->UID;
		}
		if (full)
		{
			untyped arr2[8];
			int sz = Min(SizeOfArray(arr), 16);
			for(int q = sz-1; q >= 8; --q)
			{
				arr2[q-8] = arr[q];
			}
			lweapon data = Screen->LoadLWeaponByUID(e->Misc[GWM_INITSTUFF]);
			if (data->isValid()) //If it isn't valid, then attempts to create it last time failed, so don't even bother trying again.
			{
				if (data->Misc[GWM_INITSTUFF])
				{
					lweapon data2 = Screen->LoadLWeaponByUID(data->Misc[GWM_INITSTUFF]);
					if (data2->isValid())
					{
						int sz2 = Min(SizeOfArray(arr2), 8);
						for(int q = sz2-1; q >= 0; --q)
						{
							data2->InitD[q] = arr2[q];
						}
					}
					else
					{
						data2 = CreateDataWeapon(arr2);
						data->Misc[GWM_INITSTUFF] = data2->UID;
					}
				}
				else
				{
					lweapon data2 = CreateDataWeapon(arr2);
					data->Misc[GWM_INITSTUFF] = data2->UID;
				}
			}
		}
	}
	void SetExInits2(eweapon e, untyped arr)
	{
		unless (e->Misc[GWM_INITSTUFF])
		{
			int arr2[8];
			lweapon data = CreateDataWeapon(arr2);
			e->Misc[GWM_INITSTUFF] = data->UID;
		}
		lweapon data = Screen->LoadLWeaponByUID(e->Misc[GWM_INITSTUFF]);
		unless (data->isValid())
		{
			int arr2[8];
			data = CreateDataWeapon(arr2);
			e->Misc[GWM_INITSTUFF] = data->UID;
		}
		if (data->isValid()) //If it isn't valid, then attempts to create it last time failed, so don't even bother trying again.
		{
			if (data->Misc[GWM_INITSTUFF])
			{
				lweapon data2 = Screen->LoadLWeaponByUID(data->Misc[GWM_INITSTUFF]);
				if (data2->isValid())
				{
					int sz2 = Min(SizeOfArray(arr), 8);
					for(int q = sz2-1; q >= 0; --q)
					{
						data2->InitD[q] = arr[q];
					}
				}
				else
				{
					data2 = CreateDataWeapon(arr);
					data->Misc[GWM_INITSTUFF] = data2->UID;
				}
			}
			else
			{
				lweapon data2 = CreateDataWeapon(arr);
				data->Misc[GWM_INITSTUFF] = data2->UID;
			}
		}
	}
	untyped GetExInit(eweapon e, GW_EXINIT index)
	{
		if (e->Misc[GWM_INITSTUFF])
		{
			lweapon data = Screen->LoadLWeaponByUID(e->Misc[GWM_INITSTUFF]);
			if (data->isValid())
			{
				if (index < 8) return data->InitD[index];
			}
			else return 0;
		}
		else return 0;
		if (index >= 8)
		{
			lweapon data = Screen->LoadLWeaponByUID(e->Misc[GWM_INITSTUFF]);
			if (data->isValid()) //If it isn't valid, then attempts to create it last time failed, so don't even bother trying again.
			{
				if (data->Misc[GWM_INITSTUFF])
				{
					lweapon data2 = Screen->LoadLWeaponByUID(data->Misc[GWM_INITSTUFF]);
					if (data2->isValid())
					{
						if (index < 16) return data2->InitD[index-8];
					}
					else return 0;
				}
				else return 0;
			}
			else return 0;
		}
		return 0;
	}
	untyped GetEWeaponAttribute(eweapon e, GW_INTERNAL index)
	{
		if (IsInitialized(e))
		{
			int args = e->Misc[GWM_SETTINGS];
			return args[index];
		}
		else
		{
			switch (index)
			{
				case GWI_TRUEX:
					return e->X;
					break;
					
				case GWI_TRUEY:
					return e->Y;
					break;
					
				case GWI_MOVEMENT:
					return e->InitD[0];
					break;
					
				case GWI_MOVEARG1:
					return e->InitD[1];
					break;
					
				case GWI_MOVEARG2:
					return e->InitD[2];
					break;
					
				case GWI_LIFESPAN:
					return e->InitD[3];
					break;
					
				case GWI_LIFEARG:
					return e->InitD[4];
					break;
					
				case GWI_DEATHTYPE:
					return e->InitD[5];
					break;
					
				case GWI_DEATHARG:
					return e->InitD[6];
					break;
					
				case GWI_FLAGS:
					return e->InitD[7];
					break;
					
				case GWI_MISC1:
					return GetExInit(e, GWMI_INITMISC1);
					break;
					
				case GWI_MISC2:
					return GetExInit(e, GWMI_INITMISC2);
					break;
					
				case GWI_MISC3:
					return GetExInit(e, GWMI_INITMISC3);
					break;
					
				case GWI_DUMMYWPN:
					return GetExInit(e, GWMI_PROTOTYPEUID);
					break;
					
				case GWI_DUMMYANGLE:
					return ((GetExInit(e, GWMI_PROTOTYPEMISC)%10)-6.2832);
					break;
					
				case GWI_DUMMYSHOTS:
					return GetExInit(e, GWMI_PROTOTYPESHOTS);
					break;
					
				case GWI_DUMMYTYPE:
					int angle = ((GetExInit(e, GWMI_PROTOTYPEMISC)%10)-6.2832);
					return (((GetExInit(e, GWMI_PROTOTYPEMISC)-angle)/100)>>0);
					break;
					
				case GWI_PARTICLEWPN:
					return GetExInit(e, GWMI_PARTICLEUID);
					break;
					
				case GWI_PARTICLETIMER:
					return GetExInit(e, GWMI_PARTICLETIMER);
					break;
					
				case GWI_LIFEMISC:
					return GetExInit(e, GWMI_INITLIFEMISC);
					break;
					
				case GWI_DEATHMISC:
					return GetExInit(e, GWMI_INITDEATHMISC);
					break;
					
				case GWI_DRAWXOFFSET:
					return e->DrawXOffset;
					break;
					
				case GWI_DRAWYOFFSET:
					return e->DrawYOffset;
					break;
					
				case GWI_HITXOFFSET:
					return e->HitXOffset;
					break;
					
				case GWI_HITYOFFSET:
					return e->HitYOffset;
					break;
					
				case GWI_HITWIDTH:
					return e->HitWidth;
					break;
					
				case GWI_HITHEIGHT:
					return e->HitHeight;
					break;
					
				case GWI_PARTICLEOFFSET:
					GetExInit(e, GWMI_PARTICLEOFFSET);
					break;
					
				default:
					return 0;
			}
		}
	}
	void SetEWeaponAttribute(eweapon e, GW_INTERNAL index, untyped value)
	{
		if (IsInitialized(e))
		{
			int args = e->Misc[GWM_SETTINGS];
			args[index] = value;
		}
		else
		{
			switch (index)
			{
				case GWI_TRUEX:
					e->X = value;
					break;
					
				case GWI_TRUEY:
					e->Y = value;
					break;
					
				case GWI_MOVEMENT:
					e->InitD[0] = value;
					break;
					
				case GWI_MOVEARG1:
					e->InitD[1] = value;
					break;
					
				case GWI_MOVEARG2:
					e->InitD[2] = value;
					break;
					
				case GWI_LIFESPAN:
					e->InitD[3] = value;
					break;
					
				case GWI_LIFEARG:
					e->InitD[4] = value;
					break;
					
				case GWI_DEATHTYPE:
					e->InitD[5] = value;
					break;
					
				case GWI_DEATHARG:
					e->InitD[6] = value;
					break;
					
				case GWI_FLAGS:
					e->InitD[7] = value;
					break;
					
				case GWI_MISC1:
					SetExInit(e, GWMI_INITMISC1, value);
					break;
					
				case GWI_MISC2:
					SetExInit(e, GWMI_INITMISC2, value);
					break;
					
				case GWI_MISC3:
					SetExInit(e, GWMI_INITMISC3, value);
					break;
					
				case GWI_DUMMYWPN:
					SetExInit(e, GWMI_PROTOTYPEUID, value);
					break;
					
				case GWI_DUMMYANGLE:
					int angle = ((GetExInit(e, GWMI_PROTOTYPEMISC)%10)-6.2832);
					int type =  (((GetExInit(e, GWMI_PROTOTYPEMISC)-angle)/100)>>0);
					int misc = type*100+(WrapAngle(value)+6.2832);
					SetExInit(e, GWMI_PROTOTYPEMISC, misc);
					break;
					
				case GWI_DUMMYSHOTS:
					SetExInit(e, GWMI_PROTOTYPESHOTS, value);
					break;
					
				case GWI_DUMMYTYPE:
					int angle = ((GetExInit(e, GWMI_PROTOTYPEMISC)%10)-6.2832);
					int misc = value*100+(WrapAngle(angle)+6.2832);
					SetExInit(e, GWMI_PROTOTYPEMISC, misc);
					break;
					
				case GWI_PARTICLEWPN:
					SetExInit(e, GWMI_PARTICLEUID, value);
					break;
					
				case GWI_PARTICLETIMER:
					SetExInit(e, GWMI_PARTICLETIMER, value);
					break;
					
				case GWI_LIFEMISC:
					SetExInit(e, GWMI_INITLIFEMISC, value);
					break;
					
				case GWI_DEATHMISC:
					SetExInit(e, GWMI_INITDEATHMISC, value);
					break;
					
				case GWI_DRAWXOFFSET:
					e->DrawXOffset = value;
					break;
					
				case GWI_DRAWYOFFSET:
					e->DrawYOffset = value;
					break;
					
				case GWI_HITXOFFSET:
					e->HitXOffset = value;
					break;
					
				case GWI_HITYOFFSET:
					e->HitYOffset = value;
					break;
					
				case GWI_HITWIDTH:
					e->HitWidth = value;
					break;
					
				case GWI_HITHEIGHT:
					e->HitHeight = value;
					break;
					
				case GWI_PARTICLEOFFSET:
					SetExInit(e, GWMI_PARTICLEOFFSET, value);
					break;
					
				default:
					break;
			}
		}
	}
}